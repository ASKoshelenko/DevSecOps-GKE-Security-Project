# =============================================================================
# Logstash Pipeline - Security Event Processing
# =============================================================================
#
# This pipeline processes security events from multiple sources:
#   1. Falco runtime alerts -> Parse, enrich, tag APT indicators
#   2. Suricata IDS alerts  -> Parse eve.json, GeoIP enrich, tag APT
#   3. Kubernetes audit logs -> Parse, detect suspicious API calls
#
# Pipeline stages:
#   INPUT  -> Receive from Filebeat via Beats protocol
#   FILTER -> Parse JSON, enrich with GeoIP, tag APT-related events
#   OUTPUT -> Send to Elasticsearch with proper index routing
#
# Deploy as:
#   ConfigMap mounted to /usr/share/logstash/pipeline/
#
# =============================================================================

# =============================================================================
# INPUT STAGE
# =============================================================================
# Receive events from Filebeat DaemonSets running on each GKE node.
# The Beats input protocol provides backpressure and at-least-once delivery.
# =============================================================================
input {
  beats {
    port => 5044
    host => "0.0.0.0"
    # TLS for production (uncomment and configure):
    # ssl => true
    # ssl_certificate => "/etc/pki/tls/certs/logstash.crt"
    # ssl_key => "/etc/pki/tls/private/logstash.key"
    # ssl_certificate_authorities => ["/etc/pki/tls/certs/ca.crt"]
    tags => ["beats_input"]
  }

  # Direct HTTP input for webhooks and external integrations
  http {
    port => 8080
    host => "0.0.0.0"
    codec => json
    tags => ["http_input"]
  }
}

# =============================================================================
# FILTER STAGE
# =============================================================================
filter {

  # ===========================================================================
  # Stage 1: Route by Source Type
  # ===========================================================================
  # Events are tagged by Filebeat with their source type.
  # We route to different parsing logic based on the source.
  # ===========================================================================

  # ---------------------------------------------------------------------------
  # FALCO EVENT PARSING
  # ---------------------------------------------------------------------------
  # Falco outputs JSON with fields: priority, rule, output, output_fields,
  # time, tags. We parse and normalize these for the security index.
  # ---------------------------------------------------------------------------
  if "falco" in [tags] or [source] == "falco" {

    # Parse the Falco JSON output
    json {
      source => "message"
      target => "falco"
      skip_on_invalid_json => true
    }

    # Extract priority level for severity mapping
    if [falco][priority] {
      mutate {
        add_field => {
          "event.severity" => "%{[falco][priority]}"
          "event.module" => "falco"
          "event.kind" => "alert"
          "event.category" => "intrusion_detection"
        }
      }

      # Map Falco priority to numeric severity (ECS compatible)
      # EMERGENCY=0, ALERT=1, CRITICAL=2, ERROR=3, WARNING=4, NOTICE=5, INFO=6
      translate {
        field => "[falco][priority]"
        destination => "event.severity_id"
        dictionary => {
          "Emergency" => "0"
          "Alert"     => "1"
          "Critical"  => "2"
          "Error"     => "3"
          "Warning"   => "4"
          "Notice"    => "5"
          "Informational" => "6"
          "Debug"     => "7"
        }
        fallback => "4"
      }
    }

    # Extract key fields from Falco output for easier querying
    if [falco][output_fields] {
      mutate {
        rename => {
          "[falco][output_fields][container.id]" => "container.id"
          "[falco][output_fields][container.name]" => "container.name"
          "[falco][output_fields][container.image.repository]" => "container.image.name"
          "[falco][output_fields][k8s.pod.name]" => "kubernetes.pod.name"
          "[falco][output_fields][k8s.ns.name]" => "kubernetes.namespace"
          "[falco][output_fields][proc.name]" => "process.name"
          "[falco][output_fields][proc.cmdline]" => "process.command_line"
          "[falco][output_fields][user.name]" => "user.name"
          "[falco][output_fields][fd.name]" => "file.path"
        }
      }
    }

    # Tag APT-related Falco events based on rule tags
    if [falco][tags] {
      if "apt" in [falco][tags] or "russian_apt" in [falco][tags] {
        mutate {
          add_tag => ["apt_indicator", "high_priority"]
          add_field => { "threat.framework" => "MITRE ATT&CK" }
        }
      }
      if "cryptomining" in [falco][tags] {
        mutate {
          add_tag => ["crypto_mining", "resource_hijacking"]
        }
      }
      if "container_escape" in [falco][tags] {
        mutate {
          add_tag => ["container_escape", "privilege_escalation"]
        }
      }
      if "reverse_shell" in [falco][tags] {
        mutate {
          add_tag => ["reverse_shell", "active_exploitation"]
        }
      }
    }

    # Detect "magic" file IOC in Falco output
    if [falco][rule] =~ /(?i)magic/ or [falco][output] =~ /(?i)magic/ {
      mutate {
        add_tag => ["apt_magic_file", "ioc", "critical"]
        add_field => {
          "threat.indicator.type" => "file"
          "threat.indicator.description" => "APT magic file marker detected in /tmp"
        }
      }
    }

    # Set the index destination
    mutate {
      add_field => { "[@metadata][target_index]" => "falco-alerts" }
    }
  }

  # ---------------------------------------------------------------------------
  # SURICATA EVENT PARSING
  # ---------------------------------------------------------------------------
  # Suricata eve.json is already well-structured JSON. We enrich it with
  # GeoIP data for C2 IP geolocation and tag APT-related alerts.
  # ---------------------------------------------------------------------------
  else if "suricata" in [tags] or [source] == "suricata" {

    # Parse the eve.json event
    json {
      source => "message"
      target => "suricata"
      skip_on_invalid_json => true
    }

    # Set event metadata
    mutate {
      add_field => {
        "event.module" => "suricata"
        "event.category" => "network"
      }
    }

    # Route based on eve.json event_type
    if [suricata][event_type] == "alert" {
      mutate {
        add_field => {
          "event.kind" => "alert"
          "event.type" => "indicator"
        }
      }

      # Extract alert severity
      if [suricata][alert][severity] {
        mutate {
          add_field => { "event.severity_id" => "%{[suricata][alert][severity]}" }
        }
      }

      # Tag APT-related Suricata alerts based on alert message
      if [suricata][alert][signature] =~ /(?i)APT/ {
        mutate {
          add_tag => ["apt_indicator", "high_priority"]
          add_field => { "threat.framework" => "MITRE ATT&CK" }
        }
      }

      # Tag crypto mining alerts
      if [suricata][alert][signature] =~ /(?i)(CRYPTO|MINING|stratum)/ {
        mutate {
          add_tag => ["crypto_mining", "resource_hijacking"]
        }
      }

      # Tag C2-related alerts
      if [suricata][alert][signature] =~ /(?i)(C2|callback|Metasploit|Cobalt|beacon|RAT)/ {
        mutate {
          add_tag => ["c2_communication", "apt_indicator"]
        }
      }

      # Tag exfiltration alerts
      if [suricata][alert][signature] =~ /(?i)(EXFIL|exfiltration)/ {
        mutate {
          add_tag => ["data_exfiltration"]
        }
      }

      # Tag TOR-related alerts
      if [suricata][alert][signature] =~ /(?i)TOR/ {
        mutate {
          add_tag => ["tor_network", "anonymization"]
        }
      }
    }

    # Extract source and destination IPs for GeoIP enrichment
    if [suricata][src_ip] {
      mutate {
        add_field => { "source.ip" => "%{[suricata][src_ip]}" }
      }
    }
    if [suricata][dest_ip] {
      mutate {
        add_field => { "destination.ip" => "%{[suricata][dest_ip]}" }
      }
    }
    if [suricata][src_port] {
      mutate {
        add_field => { "source.port" => "%{[suricata][src_port]}" }
      }
    }
    if [suricata][dest_port] {
      mutate {
        add_field => { "destination.port" => "%{[suricata][dest_port]}" }
      }
    }

    # GeoIP enrichment for source IP (external attackers)
    if [source.ip] {
      geoip {
        source => "source.ip"
        target => "source.geo"
        database => "/usr/share/GeoIP/GeoLite2-City.mmdb"
        tag_on_failure => ["_geoip_lookup_failure_src"]
        # Only process non-private IPs
        fields => ["city_name", "country_name", "country_code2",
                   "continent_name", "region_name", "location",
                   "timezone", "postal_code"]
      }
      geoip {
        source => "source.ip"
        target => "source.as"
        database => "/usr/share/GeoIP/GeoLite2-ASN.mmdb"
        tag_on_failure => ["_geoip_asn_failure_src"]
      }
    }

    # GeoIP enrichment for destination IP (C2 servers, mining pools)
    if [destination.ip] {
      geoip {
        source => "destination.ip"
        target => "destination.geo"
        database => "/usr/share/GeoIP/GeoLite2-City.mmdb"
        tag_on_failure => ["_geoip_lookup_failure_dst"]
        fields => ["city_name", "country_name", "country_code2",
                   "continent_name", "region_name", "location",
                   "timezone", "postal_code"]
      }
      geoip {
        source => "destination.ip"
        target => "destination.as"
        database => "/usr/share/GeoIP/GeoLite2-ASN.mmdb"
        tag_on_failure => ["_geoip_asn_failure_dst"]
      }

      # Tag connections to countries associated with Russian APT infrastructure
      if [destination.geo][country_code2] in ["RU", "CN", "KP", "IR"] {
        mutate {
          add_tag => ["suspicious_geo", "high_risk_country"]
        }
      }
    }

    # Extract JA3 fingerprints for TLS-based C2 detection
    if [suricata][tls][ja3][hash] {
      mutate {
        add_field => {
          "tls.client.ja3" => "%{[suricata][tls][ja3][hash]}"
        }
      }
      # Known malicious JA3 fingerprints (Cobalt Strike, Metasploit, etc.)
      # These should be updated from threat intel feeds regularly.
      translate {
        field => "[tls.client.ja3]"
        destination => "threat.indicator.matched"
        dictionary_path => "/etc/logstash/ja3-blacklist.yml"
        fallback => "unknown"
      }
      if [threat.indicator.matched] and [threat.indicator.matched] != "unknown" {
        mutate {
          add_tag => ["malicious_ja3", "c2_indicator"]
        }
      }
    }

    # Set the index destination
    mutate {
      add_field => { "[@metadata][target_index]" => "suricata-alerts" }
    }
  }

  # ---------------------------------------------------------------------------
  # KUBERNETES AUDIT LOG PARSING
  # ---------------------------------------------------------------------------
  # Parse K8s audit events to detect unauthorized API access, secret
  # enumeration, RBAC changes, and service account abuse.
  # ---------------------------------------------------------------------------
  else if "kubernetes" in [tags] and "audit" in [tags] or [source] == "kubernetes-audit" {

    json {
      source => "message"
      target => "k8s_audit"
      skip_on_invalid_json => true
    }

    mutate {
      add_field => {
        "event.module" => "kubernetes"
        "event.kind" => "event"
        "event.category" => "configuration"
        "[@metadata][target_index]" => "k8s-audit"
      }
    }

    # Detect suspicious API operations
    # -- Secret access (potential credential theft) --
    if [k8s_audit][objectRef][resource] == "secrets" and
       [k8s_audit][verb] in ["get", "list", "watch"] {
      mutate {
        add_tag => ["secret_access", "credential_access"]
        add_field => { "threat.technique.id" => "T1552" }
      }
    }

    # -- Service account token request --
    if [k8s_audit][objectRef][resource] == "serviceaccounts" and
       [k8s_audit][objectRef][subresource] == "token" {
      mutate {
        add_tag => ["sa_token_request", "credential_access"]
        add_field => { "threat.technique.id" => "T1528" }
      }
    }

    # -- RBAC modification (privilege escalation) --
    if [k8s_audit][objectRef][resource] in ["clusterroles", "clusterrolebindings", "roles", "rolebindings"] and
       [k8s_audit][verb] in ["create", "update", "patch", "delete"] {
      mutate {
        add_tag => ["rbac_modification", "privilege_escalation"]
        add_field => { "threat.technique.id" => "T1078" }
      }
    }

    # -- Pod exec (potential post-exploitation) --
    if [k8s_audit][objectRef][resource] == "pods" and
       [k8s_audit][objectRef][subresource] == "exec" {
      mutate {
        add_tag => ["pod_exec", "command_execution"]
        add_field => { "threat.technique.id" => "T1609" }
      }
    }

    # -- Privileged pod creation --
    if [k8s_audit][objectRef][resource] == "pods" and
       [k8s_audit][verb] == "create" and
       [k8s_audit][requestObject][spec][containers][0][securityContext][privileged] == true {
      mutate {
        add_tag => ["privileged_pod", "container_escape_risk"]
        add_field => { "threat.technique.id" => "T1611" }
      }
    }
  }

  # ---------------------------------------------------------------------------
  # CONTAINER LOG PARSING (default route)
  # ---------------------------------------------------------------------------
  else if "container" in [tags] or [source] == "container" {
    mutate {
      add_field => {
        "event.module" => "container"
        "event.kind" => "event"
        "[@metadata][target_index]" => "container-logs"
      }
    }

    # Detect suspicious patterns in container logs
    if [message] =~ /(?i)(reverse shell|backdoor|c2 server|mining|miner)/ {
      mutate {
        add_tag => ["suspicious_log", "needs_investigation"]
      }
    }
  }

  # ---------------------------------------------------------------------------
  # DEFAULT ROUTE
  # ---------------------------------------------------------------------------
  else {
    mutate {
      add_field => { "[@metadata][target_index]" => "unknown-events" }
    }
  }

  # ===========================================================================
  # Stage 2: Common Enrichment (applies to ALL events)
  # ===========================================================================

  # Add timestamp processing
  date {
    match => ["timestamp", "ISO8601", "yyyy-MM-dd'T'HH:mm:ss.SSSZ",
              "yyyy-MM-dd'T'HH:mm:ssZ", "UNIX_MS"]
    target => "@timestamp"
    tag_on_failure => ["_dateparsefailure"]
  }

  # Add a unified severity field based on tags
  if "critical" in [tags] or "active_exploitation" in [tags] {
    mutate { add_field => { "alert.severity" => "critical" } }
  } else if "apt_indicator" in [tags] or "high_priority" in [tags] {
    mutate { add_field => { "alert.severity" => "high" } }
  } else if "suspicious_log" in [tags] or "needs_investigation" in [tags] {
    mutate { add_field => { "alert.severity" => "medium" } }
  } else {
    mutate { add_field => { "alert.severity" => "low" } }
  }

  # Compute a composite APT threat score (0-100)
  # Higher score = more likely to be real APT activity
  ruby {
    code => '
      score = 0
      tags = event.get("tags") || []

      # Scoring based on tags
      score += 40 if tags.include?("apt_magic_file")
      score += 30 if tags.include?("apt_indicator")
      score += 25 if tags.include?("reverse_shell")
      score += 25 if tags.include?("container_escape")
      score += 20 if tags.include?("c2_communication")
      score += 20 if tags.include?("crypto_mining")
      score += 15 if tags.include?("data_exfiltration")
      score += 10 if tags.include?("suspicious_geo")
      score += 10 if tags.include?("malicious_ja3")
      score += 10 if tags.include?("credential_access")
      score += 5  if tags.include?("tor_network")
      score += 5  if tags.include?("suspicious_log")

      # Cap at 100
      score = [score, 100].min

      event.set("threat.score", score)
      event.set("threat.is_apt", score >= 30)
    '
  }

  # Remove internal fields not needed in Elasticsearch
  mutate {
    remove_field => ["agent.ephemeral_id", "ecs.version", "input.type",
                     "log.offset", "host.os.codename"]
  }
}

# =============================================================================
# OUTPUT STAGE
# =============================================================================
# Route events to appropriate Elasticsearch indices based on source type.
# APT-tagged events are also duplicated to a dedicated APT index for
# focused investigation.
# =============================================================================
output {

  # Primary output: route to source-specific indices
  elasticsearch {
    hosts => ["http://elasticsearch-master:9200"]
    index => "%{[@metadata][target_index]}-%{+yyyy.MM.dd}"
    # Use the index template for proper mappings
    template_name => "security-events"
    template_overwrite => true
    # ILM policy for automatic rollover and retention
    ilm_enabled => true
    ilm_rollover_alias => "security-events"
    ilm_policy => "security-events-policy"
    # Pipeline for additional Elasticsearch-side processing
    pipeline => "security-events-ingest"
    # Retry on failure
    retry_on_conflict => 3
    # TLS for production (uncomment):
    # ssl => true
    # cacert => "/etc/pki/tls/certs/elasticsearch-ca.crt"
  }

  # Duplicate APT-related events to a dedicated index for focused hunting
  if "apt_indicator" in [tags] or "apt_magic_file" in [tags] or
     [threat.is_apt] == true {
    elasticsearch {
      hosts => ["http://elasticsearch-master:9200"]
      index => "apt-detections-%{+yyyy.MM.dd}"
      ilm_enabled => true
      ilm_rollover_alias => "apt-detections"
      ilm_policy => "apt-detections-policy"
    }
  }

  # Send critical alerts to a fast-access index for real-time dashboards
  if [alert.severity] == "critical" or [alert.severity] == "high" {
    elasticsearch {
      hosts => ["http://elasticsearch-master:9200"]
      index => "critical-alerts-%{+yyyy.MM.dd}"
    }
  }

  # Debug output (disable in production)
  # stdout {
  #   codec => rubydebug
  # }
}
