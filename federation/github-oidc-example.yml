# =============================================================================
# GitHub Actions Workflow - Workload Identity Federation Authentication
# =============================================================================
#
# This workflow demonstrates how to authenticate to Google Cloud from GitHub
# Actions using Workload Identity Federation (WIF) instead of service account
# keys. WIF uses short-lived OIDC tokens that cannot be stolen or reused.
#
# SECURITY PROPERTIES:
# - No long-lived secrets stored in GitHub (no GOOGLE_CREDENTIALS secret)
# - Tokens expire after 1 hour and cannot be refreshed externally
# - Authentication is tied to specific repos, branches, and workflows
# - Every token exchange is logged in GCP Cloud Audit Logs
# - Tokens are bound to the GitHub Actions runner and cannot be exfiltrated
#
# PREREQUISITES:
# 1. Apply terraform-wif.tf to create the WIF pool, provider, and SAs
# 2. Set these GitHub Actions variables (NOT secrets - they are not sensitive):
#    - WIF_PROVIDER: Full resource name of the WIF provider
#    - WIF_DEPLOYER_SA: Email of the deployer service account
#    - WIF_READER_SA: Email of the reader service account
#    - WIF_SCANNER_SA: Email of the scanner service account
#    - GCP_PROJECT_ID: Google Cloud project ID
#    - GKE_CLUSTER: Name of the GKE cluster
#    - GKE_ZONE: Zone of the GKE cluster
#
# =============================================================================

name: "DevSecOps Pipeline with WIF"

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]
  # Allow manual trigger for testing
  workflow_dispatch:

# =============================================================================
# CRITICAL: Required permissions for OIDC token exchange
# =============================================================================
# The 'id-token: write' permission allows the GitHub Actions runner to request
# an OIDC token from GitHub's identity provider. This token is then exchanged
# for a short-lived GCP access token via the WIF provider.
#
# 'contents: read' is needed to checkout the repository code.
#
# NEVER grant more permissions than needed. Each job should declare its own
# minimal permission set.
# =============================================================================

permissions:
  # Required for OIDC token request to GitHub's identity provider
  id-token: write
  # Required for actions/checkout
  contents: read
  # Required for posting PR comments (security scan results)
  pull-requests: write
  # Required for uploading SARIF results to GitHub Security tab
  security-events: write

# Cancel in-progress runs for the same branch/PR to save resources
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

# =============================================================================
# Environment Variables
# =============================================================================

env:
  # These values come from the terraform-wif.tf outputs
  # They are NOT secrets - they are resource identifiers
  WIF_PROVIDER: ${{ vars.WIF_PROVIDER }}
  GCP_PROJECT_ID: ${{ vars.GCP_PROJECT_ID }}
  GKE_CLUSTER: ${{ vars.GKE_CLUSTER }}
  GKE_ZONE: ${{ vars.GKE_ZONE }}
  # Artifact Registry for container images
  GAR_LOCATION: us-central1
  GAR_REPOSITORY: devsecops-images

jobs:
  # ===========================================================================
  # Job 1: Security Scan (runs on all PRs and pushes)
  # ===========================================================================
  # Uses the READER service account - no write access to any GCP resource.
  # This job can run from any branch, including feature branches and PRs.
  # ===========================================================================

  security-scan:
    name: "Security Scan"
    runs-on: ubuntu-latest
    # Only restrict to our own repo (prevents forks from running this)
    if: github.repository == 'devsecops-demo/devsecops-project'

    permissions:
      id-token: write
      contents: read
      pull-requests: write
      security-events: write

    steps:
      # -----------------------------------------------------------------------
      # Step 1: Checkout code
      # -----------------------------------------------------------------------
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for proper diff analysis

      # -----------------------------------------------------------------------
      # Step 2: Authenticate to GCP via Workload Identity Federation
      # -----------------------------------------------------------------------
      # This is where the OIDC magic happens:
      # 1. actions/auth requests an OIDC token from GitHub's IdP
      # 2. The token contains claims: repo, branch, actor, workflow, etc.
      # 3. actions/auth sends this token to GCP's Security Token Service (STS)
      # 4. STS validates the token against the WIF provider's config
      # 5. STS checks the attribute conditions (org, repo, runner env)
      # 6. If valid, STS returns a federated access token
      # 7. actions/auth exchanges the federated token for a SA access token
      # 8. The SA access token is set as GOOGLE_APPLICATION_CREDENTIALS
      #
      # The entire exchange happens in-memory. No keys are written to disk.
      # -----------------------------------------------------------------------
      - name: Authenticate to Google Cloud (WIF)
        id: auth
        uses: google-github-actions/auth@v2
        with:
          # The WIF provider resource name from terraform-wif.tf output
          workload_identity_provider: ${{ env.WIF_PROVIDER }}
          # Scanner SA has read access + BigQuery write for scan results
          service_account: ${{ vars.WIF_SCANNER_SA }}
          # Token lifetime (default 3600s = 1 hour, minimum 600s = 10 minutes)
          token_format: "access_token"
          # Create credentials file for tools that need it
          create_credentials_file: true
          # Audience restriction (matches the WIF provider's allowed_audiences)
          # If not set, defaults to the provider's URL
          # audience: "https://iam.googleapis.com/..."

      # -----------------------------------------------------------------------
      # Step 3: Verify authentication worked
      # -----------------------------------------------------------------------
      - name: Verify GCP authentication
        run: |
          echo "Authenticated as: $(gcloud auth list --filter=status:ACTIVE --format='value(account)' 2>/dev/null || echo 'using ADC')"
          echo "Project: $(gcloud config get-value project 2>/dev/null || echo 'not set')"
          echo "Token expires: $(date -d @$(echo '${{ steps.auth.outputs.access_token_expiration }}' | head -c10) 2>/dev/null || echo 'N/A')"

      # -----------------------------------------------------------------------
      # Step 4: Set up GKE credentials (for scanning running workloads)
      # -----------------------------------------------------------------------
      - name: Configure GKE access
        uses: google-github-actions/get-gke-credentials@v2
        with:
          cluster_name: ${{ env.GKE_CLUSTER }}
          location: ${{ env.GKE_ZONE }}
          project_id: ${{ env.GCP_PROJECT_ID }}

      # -----------------------------------------------------------------------
      # Step 5: Run Trivy vulnerability scan
      # -----------------------------------------------------------------------
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: "fs"
          scan-ref: "."
          format: "sarif"
          output: "trivy-results.sarif"
          severity: "CRITICAL,HIGH"
          # Exit with error if critical vulnerabilities found
          exit-code: "1"
        continue-on-error: true  # Don't fail the job, report results

      # -----------------------------------------------------------------------
      # Step 6: Upload scan results to GitHub Security tab
      # -----------------------------------------------------------------------
      - name: Upload Trivy results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: "trivy-results.sarif"
          category: "trivy-filesystem"

      # -----------------------------------------------------------------------
      # Step 7: Export results to BigQuery (via WIF-authenticated SA)
      # -----------------------------------------------------------------------
      - name: Export scan results to BigQuery
        if: always()
        run: |
          # Convert SARIF to newline-delimited JSON for BigQuery
          if [ -f trivy-results.sarif ]; then
            jq -c '.runs[].results[] | {
              scan_timestamp: (now | todate),
              repository: "${{ github.repository }}",
              branch: "${{ github.ref_name }}",
              commit_sha: "${{ github.sha }}",
              actor: "${{ github.actor }}",
              rule_id: .ruleId,
              severity: .level,
              message: .message.text,
              file_path: (.locations[0].physicalLocation.artifactLocation.uri // "unknown"),
              line_number: (.locations[0].physicalLocation.region.startLine // 0)
            }' trivy-results.sarif > /tmp/bq-results.jsonl

            # Load into BigQuery
            bq load \
              --source_format=NEWLINE_DELIMITED_JSON \
              --autodetect \
              "${GCP_PROJECT_ID}:security_findings.trivy_vulnerabilities" \
              /tmp/bq-results.jsonl || echo "BigQuery export failed (non-fatal)"
          fi

      # -----------------------------------------------------------------------
      # Step 8: Run Terraform plan (read-only validation)
      # -----------------------------------------------------------------------
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.5.0"

      - name: Terraform init
        working-directory: terraform
        run: terraform init -input=false

      - name: Terraform validate
        working-directory: terraform
        run: terraform validate

      - name: Terraform plan
        working-directory: terraform
        run: terraform plan -input=false -no-color -out=tfplan
        continue-on-error: true

      # -----------------------------------------------------------------------
      # Step 9: Post scan results as PR comment
      # -----------------------------------------------------------------------
      - name: Post results to PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            let body = '## Security Scan Results\n\n';

            // Add Trivy results summary
            if (fs.existsSync('trivy-results.sarif')) {
              const sarif = JSON.parse(fs.readFileSync('trivy-results.sarif', 'utf8'));
              const results = sarif.runs?.[0]?.results || [];
              const critical = results.filter(r => r.level === 'error').length;
              const high = results.filter(r => r.level === 'warning').length;
              body += `### Vulnerability Scan\n`;
              body += `- Critical: ${critical}\n`;
              body += `- High: ${high}\n`;
              body += `- Total findings: ${results.length}\n\n`;
              if (critical > 0) {
                body += `> **Action Required**: ${critical} critical vulnerabilities found.\n\n`;
              }
            }

            body += `### Authentication\n`;
            body += `- Method: Workload Identity Federation (OIDC)\n`;
            body += `- No service account keys used\n`;
            body += `- Token-based, short-lived credentials\n`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });

  # ===========================================================================
  # Job 2: Deploy (only runs on push to main/master)
  # ===========================================================================
  # Uses the DEPLOYER service account - has write access to GKE and GAR.
  # This job is restricted to protected branches by both:
  # 1. The GitHub Actions 'if' condition below
  # 2. The WIF IAM condition on the deployer SA (branch restriction)
  #
  # Even if someone modifies the workflow file to remove the 'if' condition,
  # the WIF IAM condition will still prevent non-main branches from
  # impersonating the deployer SA. Defense in depth.
  # ===========================================================================

  deploy:
    name: "Deploy to GKE"
    runs-on: ubuntu-latest
    needs: [security-scan]
    # Only deploy from main/master branch, never from PRs
    if: >
      github.event_name == 'push' &&
      (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master') &&
      github.repository == 'devsecops-demo/devsecops-project'

    # Deployment-specific permissions
    permissions:
      id-token: write
      contents: read

    # Deployment environment with protection rules
    environment:
      name: production
      url: "https://console.cloud.google.com/kubernetes/workload?project=${{ env.GCP_PROJECT_ID }}"

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # -----------------------------------------------------------------------
      # Authenticate with the DEPLOYER service account
      # The WIF IAM condition ensures only main/master branches can impersonate
      # this SA. Attempts from other branches will fail with:
      #   "Permission 'iam.serviceAccounts.getAccessToken' denied"
      # -----------------------------------------------------------------------
      - name: Authenticate to Google Cloud (WIF - Deployer)
        id: auth
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ env.WIF_PROVIDER }}
          service_account: ${{ vars.WIF_DEPLOYER_SA }}
          token_format: "access_token"

      # -----------------------------------------------------------------------
      # Configure Docker for Artifact Registry
      # Uses the WIF token for Docker authentication (no docker login with keys)
      # -----------------------------------------------------------------------
      - name: Configure Docker for Artifact Registry
        run: |
          gcloud auth configure-docker ${{ env.GAR_LOCATION }}-docker.pkg.dev --quiet

      # -----------------------------------------------------------------------
      # Build and push container image
      # -----------------------------------------------------------------------
      - name: Build and push container image
        run: |
          IMAGE="${GAR_LOCATION}-docker.pkg.dev/${GCP_PROJECT_ID}/${GAR_REPOSITORY}/app:${GITHUB_SHA}"
          docker build -t "${IMAGE}" .
          docker push "${IMAGE}"
          echo "IMAGE=${IMAGE}" >> $GITHUB_ENV

      # -----------------------------------------------------------------------
      # Deploy to GKE
      # -----------------------------------------------------------------------
      - name: Configure GKE access
        uses: google-github-actions/get-gke-credentials@v2
        with:
          cluster_name: ${{ env.GKE_CLUSTER }}
          location: ${{ env.GKE_ZONE }}
          project_id: ${{ env.GCP_PROJECT_ID }}

      - name: Deploy to GKE
        run: |
          # Update the deployment image
          kubectl set image deployment/app \
            app="${IMAGE}" \
            --namespace=default \
            --record

          # Wait for rollout to complete
          kubectl rollout status deployment/app \
            --namespace=default \
            --timeout=300s

          echo "Deployment complete: ${IMAGE}"

  # ===========================================================================
  # Job 3: Post-Deploy Verification
  # ===========================================================================
  # Uses the READER service account for read-only verification.
  # Confirms the deployment is healthy and security controls are intact.
  # ===========================================================================

  verify:
    name: "Post-Deploy Verification"
    runs-on: ubuntu-latest
    needs: [deploy]
    if: github.event_name == 'push'

    permissions:
      id-token: write
      contents: read

    steps:
      - name: Authenticate to Google Cloud (WIF - Reader)
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ env.WIF_PROVIDER }}
          service_account: ${{ vars.WIF_READER_SA }}
          token_format: "access_token"

      - name: Configure GKE access
        uses: google-github-actions/get-gke-credentials@v2
        with:
          cluster_name: ${{ env.GKE_CLUSTER }}
          location: ${{ env.GKE_ZONE }}
          project_id: ${{ env.GCP_PROJECT_ID }}

      - name: Verify deployment health
        run: |
          echo "=== Deployment Status ==="
          kubectl get deployments --namespace=default

          echo ""
          echo "=== Pod Status ==="
          kubectl get pods --namespace=default

          echo ""
          echo "=== Security Controls ==="
          echo "Pod Security Standards:"
          kubectl get ns --show-labels | grep pod-security || echo "  Check PSS labels"

          echo ""
          echo "Network Policies:"
          kubectl get networkpolicies --all-namespaces

          echo ""
          echo "Service Accounts (Workload Identity):"
          kubectl get serviceaccounts --namespace=security-tools -o yaml | grep "iam.gke.io/gcp-service-account" || echo "  No WI annotations found"

      - name: Verify no SA keys in cluster
        run: |
          echo "Checking for SA key secrets in cluster..."
          # Look for secrets that might contain SA keys
          SUSPECT_SECRETS=$(kubectl get secrets --all-namespaces -o json | \
            jq -r '.items[] | select(.type == "Opaque") | select(.data | keys[] | test("key|credential|gcp|google"; "i")) | "\(.metadata.namespace)/\(.metadata.name)"' 2>/dev/null || echo "")

          if [ -n "${SUSPECT_SECRETS}" ]; then
            echo "WARNING: Found secrets that may contain SA keys:"
            echo "${SUSPECT_SECRETS}"
            echo ""
            echo "Investigate these secrets and migrate to Workload Identity."
            # Do not fail the pipeline, but flag for review
          else
            echo "No suspicious SA key secrets found in cluster."
          fi
